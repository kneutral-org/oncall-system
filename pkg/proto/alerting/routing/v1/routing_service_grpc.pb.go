// Alert Routing System - Service Definitions
// gRPC services for routing rule management, team management, and scheduling

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             (unknown)
// source: alerting/routing/v1/routing_service.proto

package routingv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RoutingService_CreateRoutingRule_FullMethodName   = "/alerting.routing.v1.RoutingService/CreateRoutingRule"
	RoutingService_GetRoutingRule_FullMethodName      = "/alerting.routing.v1.RoutingService/GetRoutingRule"
	RoutingService_ListRoutingRules_FullMethodName    = "/alerting.routing.v1.RoutingService/ListRoutingRules"
	RoutingService_UpdateRoutingRule_FullMethodName   = "/alerting.routing.v1.RoutingService/UpdateRoutingRule"
	RoutingService_DeleteRoutingRule_FullMethodName   = "/alerting.routing.v1.RoutingService/DeleteRoutingRule"
	RoutingService_ReorderRoutingRules_FullMethodName = "/alerting.routing.v1.RoutingService/ReorderRoutingRules"
	RoutingService_TestRoutingRule_FullMethodName     = "/alerting.routing.v1.RoutingService/TestRoutingRule"
	RoutingService_SimulateRouting_FullMethodName     = "/alerting.routing.v1.RoutingService/SimulateRouting"
	RoutingService_GetRoutingAuditLogs_FullMethodName = "/alerting.routing.v1.RoutingService/GetRoutingAuditLogs"
	RoutingService_RouteAlert_FullMethodName          = "/alerting.routing.v1.RoutingService/RouteAlert"
)

// RoutingServiceClient is the client API for RoutingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// RoutingService provides CRUD operations for routing rules
type RoutingServiceClient interface {
	// Create a new routing rule
	CreateRoutingRule(ctx context.Context, in *CreateRoutingRuleRequest, opts ...grpc.CallOption) (*RoutingRule, error)
	// Get a routing rule by ID
	GetRoutingRule(ctx context.Context, in *GetRoutingRuleRequest, opts ...grpc.CallOption) (*RoutingRule, error)
	// List routing rules with filters
	ListRoutingRules(ctx context.Context, in *ListRoutingRulesRequest, opts ...grpc.CallOption) (*ListRoutingRulesResponse, error)
	// Update a routing rule
	UpdateRoutingRule(ctx context.Context, in *UpdateRoutingRuleRequest, opts ...grpc.CallOption) (*RoutingRule, error)
	// Delete a routing rule
	DeleteRoutingRule(ctx context.Context, in *DeleteRoutingRuleRequest, opts ...grpc.CallOption) (*DeleteRoutingRuleResponse, error)
	// Reorder routing rules (update priorities)
	ReorderRoutingRules(ctx context.Context, in *ReorderRoutingRulesRequest, opts ...grpc.CallOption) (*ReorderRoutingRulesResponse, error)
	// Test a routing rule against sample alert (dry-run)
	TestRoutingRule(ctx context.Context, in *TestRoutingRuleRequest, opts ...grpc.CallOption) (*TestRoutingRuleResponse, error)
	// Simulate routing for an alert (shows which rules would match)
	SimulateRouting(ctx context.Context, in *SimulateRoutingRequest, opts ...grpc.CallOption) (*SimulateRoutingResponse, error)
	// Get routing audit logs
	GetRoutingAuditLogs(ctx context.Context, in *GetRoutingAuditLogsRequest, opts ...grpc.CallOption) (*GetRoutingAuditLogsResponse, error)
	// Execute routing for an alert (internal use by alert engine)
	RouteAlert(ctx context.Context, in *RouteAlertRequest, opts ...grpc.CallOption) (*RouteAlertResponse, error)
}

type routingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRoutingServiceClient(cc grpc.ClientConnInterface) RoutingServiceClient {
	return &routingServiceClient{cc}
}

func (c *routingServiceClient) CreateRoutingRule(ctx context.Context, in *CreateRoutingRuleRequest, opts ...grpc.CallOption) (*RoutingRule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoutingRule)
	err := c.cc.Invoke(ctx, RoutingService_CreateRoutingRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingServiceClient) GetRoutingRule(ctx context.Context, in *GetRoutingRuleRequest, opts ...grpc.CallOption) (*RoutingRule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoutingRule)
	err := c.cc.Invoke(ctx, RoutingService_GetRoutingRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingServiceClient) ListRoutingRules(ctx context.Context, in *ListRoutingRulesRequest, opts ...grpc.CallOption) (*ListRoutingRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRoutingRulesResponse)
	err := c.cc.Invoke(ctx, RoutingService_ListRoutingRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingServiceClient) UpdateRoutingRule(ctx context.Context, in *UpdateRoutingRuleRequest, opts ...grpc.CallOption) (*RoutingRule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoutingRule)
	err := c.cc.Invoke(ctx, RoutingService_UpdateRoutingRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingServiceClient) DeleteRoutingRule(ctx context.Context, in *DeleteRoutingRuleRequest, opts ...grpc.CallOption) (*DeleteRoutingRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteRoutingRuleResponse)
	err := c.cc.Invoke(ctx, RoutingService_DeleteRoutingRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingServiceClient) ReorderRoutingRules(ctx context.Context, in *ReorderRoutingRulesRequest, opts ...grpc.CallOption) (*ReorderRoutingRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReorderRoutingRulesResponse)
	err := c.cc.Invoke(ctx, RoutingService_ReorderRoutingRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingServiceClient) TestRoutingRule(ctx context.Context, in *TestRoutingRuleRequest, opts ...grpc.CallOption) (*TestRoutingRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestRoutingRuleResponse)
	err := c.cc.Invoke(ctx, RoutingService_TestRoutingRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingServiceClient) SimulateRouting(ctx context.Context, in *SimulateRoutingRequest, opts ...grpc.CallOption) (*SimulateRoutingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SimulateRoutingResponse)
	err := c.cc.Invoke(ctx, RoutingService_SimulateRouting_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingServiceClient) GetRoutingAuditLogs(ctx context.Context, in *GetRoutingAuditLogsRequest, opts ...grpc.CallOption) (*GetRoutingAuditLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRoutingAuditLogsResponse)
	err := c.cc.Invoke(ctx, RoutingService_GetRoutingAuditLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routingServiceClient) RouteAlert(ctx context.Context, in *RouteAlertRequest, opts ...grpc.CallOption) (*RouteAlertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RouteAlertResponse)
	err := c.cc.Invoke(ctx, RoutingService_RouteAlert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoutingServiceServer is the server API for RoutingService service.
// All implementations must embed UnimplementedRoutingServiceServer
// for forward compatibility.
//
// RoutingService provides CRUD operations for routing rules
type RoutingServiceServer interface {
	// Create a new routing rule
	CreateRoutingRule(context.Context, *CreateRoutingRuleRequest) (*RoutingRule, error)
	// Get a routing rule by ID
	GetRoutingRule(context.Context, *GetRoutingRuleRequest) (*RoutingRule, error)
	// List routing rules with filters
	ListRoutingRules(context.Context, *ListRoutingRulesRequest) (*ListRoutingRulesResponse, error)
	// Update a routing rule
	UpdateRoutingRule(context.Context, *UpdateRoutingRuleRequest) (*RoutingRule, error)
	// Delete a routing rule
	DeleteRoutingRule(context.Context, *DeleteRoutingRuleRequest) (*DeleteRoutingRuleResponse, error)
	// Reorder routing rules (update priorities)
	ReorderRoutingRules(context.Context, *ReorderRoutingRulesRequest) (*ReorderRoutingRulesResponse, error)
	// Test a routing rule against sample alert (dry-run)
	TestRoutingRule(context.Context, *TestRoutingRuleRequest) (*TestRoutingRuleResponse, error)
	// Simulate routing for an alert (shows which rules would match)
	SimulateRouting(context.Context, *SimulateRoutingRequest) (*SimulateRoutingResponse, error)
	// Get routing audit logs
	GetRoutingAuditLogs(context.Context, *GetRoutingAuditLogsRequest) (*GetRoutingAuditLogsResponse, error)
	// Execute routing for an alert (internal use by alert engine)
	RouteAlert(context.Context, *RouteAlertRequest) (*RouteAlertResponse, error)
	mustEmbedUnimplementedRoutingServiceServer()
}

// UnimplementedRoutingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRoutingServiceServer struct{}

func (UnimplementedRoutingServiceServer) CreateRoutingRule(context.Context, *CreateRoutingRuleRequest) (*RoutingRule, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateRoutingRule not implemented")
}
func (UnimplementedRoutingServiceServer) GetRoutingRule(context.Context, *GetRoutingRuleRequest) (*RoutingRule, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRoutingRule not implemented")
}
func (UnimplementedRoutingServiceServer) ListRoutingRules(context.Context, *ListRoutingRulesRequest) (*ListRoutingRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRoutingRules not implemented")
}
func (UnimplementedRoutingServiceServer) UpdateRoutingRule(context.Context, *UpdateRoutingRuleRequest) (*RoutingRule, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateRoutingRule not implemented")
}
func (UnimplementedRoutingServiceServer) DeleteRoutingRule(context.Context, *DeleteRoutingRuleRequest) (*DeleteRoutingRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteRoutingRule not implemented")
}
func (UnimplementedRoutingServiceServer) ReorderRoutingRules(context.Context, *ReorderRoutingRulesRequest) (*ReorderRoutingRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReorderRoutingRules not implemented")
}
func (UnimplementedRoutingServiceServer) TestRoutingRule(context.Context, *TestRoutingRuleRequest) (*TestRoutingRuleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TestRoutingRule not implemented")
}
func (UnimplementedRoutingServiceServer) SimulateRouting(context.Context, *SimulateRoutingRequest) (*SimulateRoutingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SimulateRouting not implemented")
}
func (UnimplementedRoutingServiceServer) GetRoutingAuditLogs(context.Context, *GetRoutingAuditLogsRequest) (*GetRoutingAuditLogsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRoutingAuditLogs not implemented")
}
func (UnimplementedRoutingServiceServer) RouteAlert(context.Context, *RouteAlertRequest) (*RouteAlertResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RouteAlert not implemented")
}
func (UnimplementedRoutingServiceServer) mustEmbedUnimplementedRoutingServiceServer() {}
func (UnimplementedRoutingServiceServer) testEmbeddedByValue()                        {}

// UnsafeRoutingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoutingServiceServer will
// result in compilation errors.
type UnsafeRoutingServiceServer interface {
	mustEmbedUnimplementedRoutingServiceServer()
}

func RegisterRoutingServiceServer(s grpc.ServiceRegistrar, srv RoutingServiceServer) {
	// If the following call panics, it indicates UnimplementedRoutingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RoutingService_ServiceDesc, srv)
}

func _RoutingService_CreateRoutingRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRoutingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingServiceServer).CreateRoutingRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutingService_CreateRoutingRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingServiceServer).CreateRoutingRule(ctx, req.(*CreateRoutingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingService_GetRoutingRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoutingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingServiceServer).GetRoutingRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutingService_GetRoutingRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingServiceServer).GetRoutingRule(ctx, req.(*GetRoutingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingService_ListRoutingRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRoutingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingServiceServer).ListRoutingRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutingService_ListRoutingRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingServiceServer).ListRoutingRules(ctx, req.(*ListRoutingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingService_UpdateRoutingRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRoutingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingServiceServer).UpdateRoutingRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutingService_UpdateRoutingRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingServiceServer).UpdateRoutingRule(ctx, req.(*UpdateRoutingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingService_DeleteRoutingRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRoutingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingServiceServer).DeleteRoutingRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutingService_DeleteRoutingRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingServiceServer).DeleteRoutingRule(ctx, req.(*DeleteRoutingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingService_ReorderRoutingRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReorderRoutingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingServiceServer).ReorderRoutingRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutingService_ReorderRoutingRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingServiceServer).ReorderRoutingRules(ctx, req.(*ReorderRoutingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingService_TestRoutingRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestRoutingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingServiceServer).TestRoutingRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutingService_TestRoutingRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingServiceServer).TestRoutingRule(ctx, req.(*TestRoutingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingService_SimulateRouting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SimulateRoutingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingServiceServer).SimulateRouting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutingService_SimulateRouting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingServiceServer).SimulateRouting(ctx, req.(*SimulateRoutingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingService_GetRoutingAuditLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoutingAuditLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingServiceServer).GetRoutingAuditLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutingService_GetRoutingAuditLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingServiceServer).GetRoutingAuditLogs(ctx, req.(*GetRoutingAuditLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoutingService_RouteAlert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteAlertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutingServiceServer).RouteAlert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoutingService_RouteAlert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutingServiceServer).RouteAlert(ctx, req.(*RouteAlertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RoutingService_ServiceDesc is the grpc.ServiceDesc for RoutingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoutingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "alerting.routing.v1.RoutingService",
	HandlerType: (*RoutingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRoutingRule",
			Handler:    _RoutingService_CreateRoutingRule_Handler,
		},
		{
			MethodName: "GetRoutingRule",
			Handler:    _RoutingService_GetRoutingRule_Handler,
		},
		{
			MethodName: "ListRoutingRules",
			Handler:    _RoutingService_ListRoutingRules_Handler,
		},
		{
			MethodName: "UpdateRoutingRule",
			Handler:    _RoutingService_UpdateRoutingRule_Handler,
		},
		{
			MethodName: "DeleteRoutingRule",
			Handler:    _RoutingService_DeleteRoutingRule_Handler,
		},
		{
			MethodName: "ReorderRoutingRules",
			Handler:    _RoutingService_ReorderRoutingRules_Handler,
		},
		{
			MethodName: "TestRoutingRule",
			Handler:    _RoutingService_TestRoutingRule_Handler,
		},
		{
			MethodName: "SimulateRouting",
			Handler:    _RoutingService_SimulateRouting_Handler,
		},
		{
			MethodName: "GetRoutingAuditLogs",
			Handler:    _RoutingService_GetRoutingAuditLogs_Handler,
		},
		{
			MethodName: "RouteAlert",
			Handler:    _RoutingService_RouteAlert_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "alerting/routing/v1/routing_service.proto",
}

const (
	TeamService_CreateTeam_FullMethodName       = "/alerting.routing.v1.TeamService/CreateTeam"
	TeamService_GetTeam_FullMethodName          = "/alerting.routing.v1.TeamService/GetTeam"
	TeamService_ListTeams_FullMethodName        = "/alerting.routing.v1.TeamService/ListTeams"
	TeamService_UpdateTeam_FullMethodName       = "/alerting.routing.v1.TeamService/UpdateTeam"
	TeamService_DeleteTeam_FullMethodName       = "/alerting.routing.v1.TeamService/DeleteTeam"
	TeamService_AddTeamMember_FullMethodName    = "/alerting.routing.v1.TeamService/AddTeamMember"
	TeamService_RemoveTeamMember_FullMethodName = "/alerting.routing.v1.TeamService/RemoveTeamMember"
	TeamService_UpdateTeamMember_FullMethodName = "/alerting.routing.v1.TeamService/UpdateTeamMember"
	TeamService_GetUserTeams_FullMethodName     = "/alerting.routing.v1.TeamService/GetUserTeams"
)

// TeamServiceClient is the client API for TeamService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TeamServiceClient interface {
	// Team CRUD
	CreateTeam(ctx context.Context, in *CreateTeamRequest, opts ...grpc.CallOption) (*Team, error)
	GetTeam(ctx context.Context, in *GetTeamRequest, opts ...grpc.CallOption) (*Team, error)
	ListTeams(ctx context.Context, in *ListTeamsRequest, opts ...grpc.CallOption) (*ListTeamsResponse, error)
	UpdateTeam(ctx context.Context, in *UpdateTeamRequest, opts ...grpc.CallOption) (*Team, error)
	DeleteTeam(ctx context.Context, in *DeleteTeamRequest, opts ...grpc.CallOption) (*DeleteTeamResponse, error)
	// Member management
	AddTeamMember(ctx context.Context, in *AddTeamMemberRequest, opts ...grpc.CallOption) (*Team, error)
	RemoveTeamMember(ctx context.Context, in *RemoveTeamMemberRequest, opts ...grpc.CallOption) (*Team, error)
	UpdateTeamMember(ctx context.Context, in *UpdateTeamMemberRequest, opts ...grpc.CallOption) (*Team, error)
	// Get teams for a user
	GetUserTeams(ctx context.Context, in *GetUserTeamsRequest, opts ...grpc.CallOption) (*ListTeamsResponse, error)
}

type teamServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTeamServiceClient(cc grpc.ClientConnInterface) TeamServiceClient {
	return &teamServiceClient{cc}
}

func (c *teamServiceClient) CreateTeam(ctx context.Context, in *CreateTeamRequest, opts ...grpc.CallOption) (*Team, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Team)
	err := c.cc.Invoke(ctx, TeamService_CreateTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamServiceClient) GetTeam(ctx context.Context, in *GetTeamRequest, opts ...grpc.CallOption) (*Team, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Team)
	err := c.cc.Invoke(ctx, TeamService_GetTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamServiceClient) ListTeams(ctx context.Context, in *ListTeamsRequest, opts ...grpc.CallOption) (*ListTeamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTeamsResponse)
	err := c.cc.Invoke(ctx, TeamService_ListTeams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamServiceClient) UpdateTeam(ctx context.Context, in *UpdateTeamRequest, opts ...grpc.CallOption) (*Team, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Team)
	err := c.cc.Invoke(ctx, TeamService_UpdateTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamServiceClient) DeleteTeam(ctx context.Context, in *DeleteTeamRequest, opts ...grpc.CallOption) (*DeleteTeamResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteTeamResponse)
	err := c.cc.Invoke(ctx, TeamService_DeleteTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamServiceClient) AddTeamMember(ctx context.Context, in *AddTeamMemberRequest, opts ...grpc.CallOption) (*Team, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Team)
	err := c.cc.Invoke(ctx, TeamService_AddTeamMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamServiceClient) RemoveTeamMember(ctx context.Context, in *RemoveTeamMemberRequest, opts ...grpc.CallOption) (*Team, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Team)
	err := c.cc.Invoke(ctx, TeamService_RemoveTeamMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamServiceClient) UpdateTeamMember(ctx context.Context, in *UpdateTeamMemberRequest, opts ...grpc.CallOption) (*Team, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Team)
	err := c.cc.Invoke(ctx, TeamService_UpdateTeamMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teamServiceClient) GetUserTeams(ctx context.Context, in *GetUserTeamsRequest, opts ...grpc.CallOption) (*ListTeamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTeamsResponse)
	err := c.cc.Invoke(ctx, TeamService_GetUserTeams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TeamServiceServer is the server API for TeamService service.
// All implementations must embed UnimplementedTeamServiceServer
// for forward compatibility.
type TeamServiceServer interface {
	// Team CRUD
	CreateTeam(context.Context, *CreateTeamRequest) (*Team, error)
	GetTeam(context.Context, *GetTeamRequest) (*Team, error)
	ListTeams(context.Context, *ListTeamsRequest) (*ListTeamsResponse, error)
	UpdateTeam(context.Context, *UpdateTeamRequest) (*Team, error)
	DeleteTeam(context.Context, *DeleteTeamRequest) (*DeleteTeamResponse, error)
	// Member management
	AddTeamMember(context.Context, *AddTeamMemberRequest) (*Team, error)
	RemoveTeamMember(context.Context, *RemoveTeamMemberRequest) (*Team, error)
	UpdateTeamMember(context.Context, *UpdateTeamMemberRequest) (*Team, error)
	// Get teams for a user
	GetUserTeams(context.Context, *GetUserTeamsRequest) (*ListTeamsResponse, error)
	mustEmbedUnimplementedTeamServiceServer()
}

// UnimplementedTeamServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTeamServiceServer struct{}

func (UnimplementedTeamServiceServer) CreateTeam(context.Context, *CreateTeamRequest) (*Team, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateTeam not implemented")
}
func (UnimplementedTeamServiceServer) GetTeam(context.Context, *GetTeamRequest) (*Team, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTeam not implemented")
}
func (UnimplementedTeamServiceServer) ListTeams(context.Context, *ListTeamsRequest) (*ListTeamsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTeams not implemented")
}
func (UnimplementedTeamServiceServer) UpdateTeam(context.Context, *UpdateTeamRequest) (*Team, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTeam not implemented")
}
func (UnimplementedTeamServiceServer) DeleteTeam(context.Context, *DeleteTeamRequest) (*DeleteTeamResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteTeam not implemented")
}
func (UnimplementedTeamServiceServer) AddTeamMember(context.Context, *AddTeamMemberRequest) (*Team, error) {
	return nil, status.Error(codes.Unimplemented, "method AddTeamMember not implemented")
}
func (UnimplementedTeamServiceServer) RemoveTeamMember(context.Context, *RemoveTeamMemberRequest) (*Team, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveTeamMember not implemented")
}
func (UnimplementedTeamServiceServer) UpdateTeamMember(context.Context, *UpdateTeamMemberRequest) (*Team, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTeamMember not implemented")
}
func (UnimplementedTeamServiceServer) GetUserTeams(context.Context, *GetUserTeamsRequest) (*ListTeamsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserTeams not implemented")
}
func (UnimplementedTeamServiceServer) mustEmbedUnimplementedTeamServiceServer() {}
func (UnimplementedTeamServiceServer) testEmbeddedByValue()                     {}

// UnsafeTeamServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TeamServiceServer will
// result in compilation errors.
type UnsafeTeamServiceServer interface {
	mustEmbedUnimplementedTeamServiceServer()
}

func RegisterTeamServiceServer(s grpc.ServiceRegistrar, srv TeamServiceServer) {
	// If the following call panics, it indicates UnimplementedTeamServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TeamService_ServiceDesc, srv)
}

func _TeamService_CreateTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamServiceServer).CreateTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeamService_CreateTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamServiceServer).CreateTeam(ctx, req.(*CreateTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeamService_GetTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamServiceServer).GetTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeamService_GetTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamServiceServer).GetTeam(ctx, req.(*GetTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeamService_ListTeams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTeamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamServiceServer).ListTeams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeamService_ListTeams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamServiceServer).ListTeams(ctx, req.(*ListTeamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeamService_UpdateTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamServiceServer).UpdateTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeamService_UpdateTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamServiceServer).UpdateTeam(ctx, req.(*UpdateTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeamService_DeleteTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamServiceServer).DeleteTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeamService_DeleteTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamServiceServer).DeleteTeam(ctx, req.(*DeleteTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeamService_AddTeamMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTeamMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamServiceServer).AddTeamMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeamService_AddTeamMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamServiceServer).AddTeamMember(ctx, req.(*AddTeamMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeamService_RemoveTeamMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveTeamMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamServiceServer).RemoveTeamMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeamService_RemoveTeamMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamServiceServer).RemoveTeamMember(ctx, req.(*RemoveTeamMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeamService_UpdateTeamMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamServiceServer).UpdateTeamMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeamService_UpdateTeamMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamServiceServer).UpdateTeamMember(ctx, req.(*UpdateTeamMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeamService_GetUserTeams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserTeamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeamServiceServer).GetUserTeams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeamService_GetUserTeams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeamServiceServer).GetUserTeams(ctx, req.(*GetUserTeamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TeamService_ServiceDesc is the grpc.ServiceDesc for TeamService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TeamService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "alerting.routing.v1.TeamService",
	HandlerType: (*TeamServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTeam",
			Handler:    _TeamService_CreateTeam_Handler,
		},
		{
			MethodName: "GetTeam",
			Handler:    _TeamService_GetTeam_Handler,
		},
		{
			MethodName: "ListTeams",
			Handler:    _TeamService_ListTeams_Handler,
		},
		{
			MethodName: "UpdateTeam",
			Handler:    _TeamService_UpdateTeam_Handler,
		},
		{
			MethodName: "DeleteTeam",
			Handler:    _TeamService_DeleteTeam_Handler,
		},
		{
			MethodName: "AddTeamMember",
			Handler:    _TeamService_AddTeamMember_Handler,
		},
		{
			MethodName: "RemoveTeamMember",
			Handler:    _TeamService_RemoveTeamMember_Handler,
		},
		{
			MethodName: "UpdateTeamMember",
			Handler:    _TeamService_UpdateTeamMember_Handler,
		},
		{
			MethodName: "GetUserTeams",
			Handler:    _TeamService_GetUserTeams_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "alerting/routing/v1/routing_service.proto",
}

const (
	ScheduleService_CreateSchedule_FullMethodName     = "/alerting.routing.v1.ScheduleService/CreateSchedule"
	ScheduleService_GetSchedule_FullMethodName        = "/alerting.routing.v1.ScheduleService/GetSchedule"
	ScheduleService_ListSchedules_FullMethodName      = "/alerting.routing.v1.ScheduleService/ListSchedules"
	ScheduleService_UpdateSchedule_FullMethodName     = "/alerting.routing.v1.ScheduleService/UpdateSchedule"
	ScheduleService_DeleteSchedule_FullMethodName     = "/alerting.routing.v1.ScheduleService/DeleteSchedule"
	ScheduleService_AddRotation_FullMethodName        = "/alerting.routing.v1.ScheduleService/AddRotation"
	ScheduleService_UpdateRotation_FullMethodName     = "/alerting.routing.v1.ScheduleService/UpdateRotation"
	ScheduleService_RemoveRotation_FullMethodName     = "/alerting.routing.v1.ScheduleService/RemoveRotation"
	ScheduleService_CreateOverride_FullMethodName     = "/alerting.routing.v1.ScheduleService/CreateOverride"
	ScheduleService_DeleteOverride_FullMethodName     = "/alerting.routing.v1.ScheduleService/DeleteOverride"
	ScheduleService_ListOverrides_FullMethodName      = "/alerting.routing.v1.ScheduleService/ListOverrides"
	ScheduleService_GetCurrentOnCall_FullMethodName   = "/alerting.routing.v1.ScheduleService/GetCurrentOnCall"
	ScheduleService_GetOnCallAtTime_FullMethodName    = "/alerting.routing.v1.ScheduleService/GetOnCallAtTime"
	ScheduleService_ListUpcomingShifts_FullMethodName = "/alerting.routing.v1.ScheduleService/ListUpcomingShifts"
	ScheduleService_AcknowledgeHandoff_FullMethodName = "/alerting.routing.v1.ScheduleService/AcknowledgeHandoff"
	ScheduleService_GetHandoffSummary_FullMethodName  = "/alerting.routing.v1.ScheduleService/GetHandoffSummary"
)

// ScheduleServiceClient is the client API for ScheduleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ScheduleServiceClient interface {
	// Schedule CRUD
	CreateSchedule(ctx context.Context, in *CreateScheduleRequest, opts ...grpc.CallOption) (*Schedule, error)
	GetSchedule(ctx context.Context, in *GetScheduleRequest, opts ...grpc.CallOption) (*Schedule, error)
	ListSchedules(ctx context.Context, in *ListSchedulesRequest, opts ...grpc.CallOption) (*ListSchedulesResponse, error)
	UpdateSchedule(ctx context.Context, in *UpdateScheduleRequest, opts ...grpc.CallOption) (*Schedule, error)
	DeleteSchedule(ctx context.Context, in *DeleteScheduleRequest, opts ...grpc.CallOption) (*DeleteScheduleResponse, error)
	// Rotation management
	AddRotation(ctx context.Context, in *AddRotationRequest, opts ...grpc.CallOption) (*Schedule, error)
	UpdateRotation(ctx context.Context, in *UpdateRotationRequest, opts ...grpc.CallOption) (*Schedule, error)
	RemoveRotation(ctx context.Context, in *RemoveRotationRequest, opts ...grpc.CallOption) (*Schedule, error)
	// Override management
	CreateOverride(ctx context.Context, in *CreateOverrideRequest, opts ...grpc.CallOption) (*ScheduleOverride, error)
	DeleteOverride(ctx context.Context, in *DeleteOverrideRequest, opts ...grpc.CallOption) (*DeleteOverrideResponse, error)
	ListOverrides(ctx context.Context, in *ListOverridesRequest, opts ...grpc.CallOption) (*ListOverridesResponse, error)
	// On-call queries
	GetCurrentOnCall(ctx context.Context, in *GetCurrentOnCallRequest, opts ...grpc.CallOption) (*GetCurrentOnCallResponse, error)
	GetOnCallAtTime(ctx context.Context, in *GetOnCallAtTimeRequest, opts ...grpc.CallOption) (*GetOnCallAtTimeResponse, error)
	ListUpcomingShifts(ctx context.Context, in *ListUpcomingShiftsRequest, opts ...grpc.CallOption) (*ListUpcomingShiftsResponse, error)
	// Handoff
	AcknowledgeHandoff(ctx context.Context, in *AcknowledgeHandoffRequest, opts ...grpc.CallOption) (*AcknowledgeHandoffResponse, error)
	GetHandoffSummary(ctx context.Context, in *GetHandoffSummaryRequest, opts ...grpc.CallOption) (*HandoffSummary, error)
}

type scheduleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewScheduleServiceClient(cc grpc.ClientConnInterface) ScheduleServiceClient {
	return &scheduleServiceClient{cc}
}

func (c *scheduleServiceClient) CreateSchedule(ctx context.Context, in *CreateScheduleRequest, opts ...grpc.CallOption) (*Schedule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Schedule)
	err := c.cc.Invoke(ctx, ScheduleService_CreateSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) GetSchedule(ctx context.Context, in *GetScheduleRequest, opts ...grpc.CallOption) (*Schedule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Schedule)
	err := c.cc.Invoke(ctx, ScheduleService_GetSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) ListSchedules(ctx context.Context, in *ListSchedulesRequest, opts ...grpc.CallOption) (*ListSchedulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSchedulesResponse)
	err := c.cc.Invoke(ctx, ScheduleService_ListSchedules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) UpdateSchedule(ctx context.Context, in *UpdateScheduleRequest, opts ...grpc.CallOption) (*Schedule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Schedule)
	err := c.cc.Invoke(ctx, ScheduleService_UpdateSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) DeleteSchedule(ctx context.Context, in *DeleteScheduleRequest, opts ...grpc.CallOption) (*DeleteScheduleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteScheduleResponse)
	err := c.cc.Invoke(ctx, ScheduleService_DeleteSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) AddRotation(ctx context.Context, in *AddRotationRequest, opts ...grpc.CallOption) (*Schedule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Schedule)
	err := c.cc.Invoke(ctx, ScheduleService_AddRotation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) UpdateRotation(ctx context.Context, in *UpdateRotationRequest, opts ...grpc.CallOption) (*Schedule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Schedule)
	err := c.cc.Invoke(ctx, ScheduleService_UpdateRotation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) RemoveRotation(ctx context.Context, in *RemoveRotationRequest, opts ...grpc.CallOption) (*Schedule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Schedule)
	err := c.cc.Invoke(ctx, ScheduleService_RemoveRotation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) CreateOverride(ctx context.Context, in *CreateOverrideRequest, opts ...grpc.CallOption) (*ScheduleOverride, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleOverride)
	err := c.cc.Invoke(ctx, ScheduleService_CreateOverride_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) DeleteOverride(ctx context.Context, in *DeleteOverrideRequest, opts ...grpc.CallOption) (*DeleteOverrideResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteOverrideResponse)
	err := c.cc.Invoke(ctx, ScheduleService_DeleteOverride_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) ListOverrides(ctx context.Context, in *ListOverridesRequest, opts ...grpc.CallOption) (*ListOverridesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOverridesResponse)
	err := c.cc.Invoke(ctx, ScheduleService_ListOverrides_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) GetCurrentOnCall(ctx context.Context, in *GetCurrentOnCallRequest, opts ...grpc.CallOption) (*GetCurrentOnCallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCurrentOnCallResponse)
	err := c.cc.Invoke(ctx, ScheduleService_GetCurrentOnCall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) GetOnCallAtTime(ctx context.Context, in *GetOnCallAtTimeRequest, opts ...grpc.CallOption) (*GetOnCallAtTimeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOnCallAtTimeResponse)
	err := c.cc.Invoke(ctx, ScheduleService_GetOnCallAtTime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) ListUpcomingShifts(ctx context.Context, in *ListUpcomingShiftsRequest, opts ...grpc.CallOption) (*ListUpcomingShiftsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUpcomingShiftsResponse)
	err := c.cc.Invoke(ctx, ScheduleService_ListUpcomingShifts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) AcknowledgeHandoff(ctx context.Context, in *AcknowledgeHandoffRequest, opts ...grpc.CallOption) (*AcknowledgeHandoffResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AcknowledgeHandoffResponse)
	err := c.cc.Invoke(ctx, ScheduleService_AcknowledgeHandoff_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scheduleServiceClient) GetHandoffSummary(ctx context.Context, in *GetHandoffSummaryRequest, opts ...grpc.CallOption) (*HandoffSummary, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HandoffSummary)
	err := c.cc.Invoke(ctx, ScheduleService_GetHandoffSummary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ScheduleServiceServer is the server API for ScheduleService service.
// All implementations must embed UnimplementedScheduleServiceServer
// for forward compatibility.
type ScheduleServiceServer interface {
	// Schedule CRUD
	CreateSchedule(context.Context, *CreateScheduleRequest) (*Schedule, error)
	GetSchedule(context.Context, *GetScheduleRequest) (*Schedule, error)
	ListSchedules(context.Context, *ListSchedulesRequest) (*ListSchedulesResponse, error)
	UpdateSchedule(context.Context, *UpdateScheduleRequest) (*Schedule, error)
	DeleteSchedule(context.Context, *DeleteScheduleRequest) (*DeleteScheduleResponse, error)
	// Rotation management
	AddRotation(context.Context, *AddRotationRequest) (*Schedule, error)
	UpdateRotation(context.Context, *UpdateRotationRequest) (*Schedule, error)
	RemoveRotation(context.Context, *RemoveRotationRequest) (*Schedule, error)
	// Override management
	CreateOverride(context.Context, *CreateOverrideRequest) (*ScheduleOverride, error)
	DeleteOverride(context.Context, *DeleteOverrideRequest) (*DeleteOverrideResponse, error)
	ListOverrides(context.Context, *ListOverridesRequest) (*ListOverridesResponse, error)
	// On-call queries
	GetCurrentOnCall(context.Context, *GetCurrentOnCallRequest) (*GetCurrentOnCallResponse, error)
	GetOnCallAtTime(context.Context, *GetOnCallAtTimeRequest) (*GetOnCallAtTimeResponse, error)
	ListUpcomingShifts(context.Context, *ListUpcomingShiftsRequest) (*ListUpcomingShiftsResponse, error)
	// Handoff
	AcknowledgeHandoff(context.Context, *AcknowledgeHandoffRequest) (*AcknowledgeHandoffResponse, error)
	GetHandoffSummary(context.Context, *GetHandoffSummaryRequest) (*HandoffSummary, error)
	mustEmbedUnimplementedScheduleServiceServer()
}

// UnimplementedScheduleServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedScheduleServiceServer struct{}

func (UnimplementedScheduleServiceServer) CreateSchedule(context.Context, *CreateScheduleRequest) (*Schedule, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSchedule not implemented")
}
func (UnimplementedScheduleServiceServer) GetSchedule(context.Context, *GetScheduleRequest) (*Schedule, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSchedule not implemented")
}
func (UnimplementedScheduleServiceServer) ListSchedules(context.Context, *ListSchedulesRequest) (*ListSchedulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSchedules not implemented")
}
func (UnimplementedScheduleServiceServer) UpdateSchedule(context.Context, *UpdateScheduleRequest) (*Schedule, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSchedule not implemented")
}
func (UnimplementedScheduleServiceServer) DeleteSchedule(context.Context, *DeleteScheduleRequest) (*DeleteScheduleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSchedule not implemented")
}
func (UnimplementedScheduleServiceServer) AddRotation(context.Context, *AddRotationRequest) (*Schedule, error) {
	return nil, status.Error(codes.Unimplemented, "method AddRotation not implemented")
}
func (UnimplementedScheduleServiceServer) UpdateRotation(context.Context, *UpdateRotationRequest) (*Schedule, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateRotation not implemented")
}
func (UnimplementedScheduleServiceServer) RemoveRotation(context.Context, *RemoveRotationRequest) (*Schedule, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveRotation not implemented")
}
func (UnimplementedScheduleServiceServer) CreateOverride(context.Context, *CreateOverrideRequest) (*ScheduleOverride, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateOverride not implemented")
}
func (UnimplementedScheduleServiceServer) DeleteOverride(context.Context, *DeleteOverrideRequest) (*DeleteOverrideResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteOverride not implemented")
}
func (UnimplementedScheduleServiceServer) ListOverrides(context.Context, *ListOverridesRequest) (*ListOverridesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListOverrides not implemented")
}
func (UnimplementedScheduleServiceServer) GetCurrentOnCall(context.Context, *GetCurrentOnCallRequest) (*GetCurrentOnCallResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCurrentOnCall not implemented")
}
func (UnimplementedScheduleServiceServer) GetOnCallAtTime(context.Context, *GetOnCallAtTimeRequest) (*GetOnCallAtTimeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOnCallAtTime not implemented")
}
func (UnimplementedScheduleServiceServer) ListUpcomingShifts(context.Context, *ListUpcomingShiftsRequest) (*ListUpcomingShiftsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListUpcomingShifts not implemented")
}
func (UnimplementedScheduleServiceServer) AcknowledgeHandoff(context.Context, *AcknowledgeHandoffRequest) (*AcknowledgeHandoffResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AcknowledgeHandoff not implemented")
}
func (UnimplementedScheduleServiceServer) GetHandoffSummary(context.Context, *GetHandoffSummaryRequest) (*HandoffSummary, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHandoffSummary not implemented")
}
func (UnimplementedScheduleServiceServer) mustEmbedUnimplementedScheduleServiceServer() {}
func (UnimplementedScheduleServiceServer) testEmbeddedByValue()                         {}

// UnsafeScheduleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ScheduleServiceServer will
// result in compilation errors.
type UnsafeScheduleServiceServer interface {
	mustEmbedUnimplementedScheduleServiceServer()
}

func RegisterScheduleServiceServer(s grpc.ServiceRegistrar, srv ScheduleServiceServer) {
	// If the following call panics, it indicates UnimplementedScheduleServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ScheduleService_ServiceDesc, srv)
}

func _ScheduleService_CreateSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).CreateSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_CreateSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).CreateSchedule(ctx, req.(*CreateScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_GetSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).GetSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_GetSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).GetSchedule(ctx, req.(*GetScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_ListSchedules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSchedulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).ListSchedules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_ListSchedules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).ListSchedules(ctx, req.(*ListSchedulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_UpdateSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).UpdateSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_UpdateSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).UpdateSchedule(ctx, req.(*UpdateScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_DeleteSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).DeleteSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_DeleteSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).DeleteSchedule(ctx, req.(*DeleteScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_AddRotation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRotationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).AddRotation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_AddRotation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).AddRotation(ctx, req.(*AddRotationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_UpdateRotation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRotationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).UpdateRotation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_UpdateRotation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).UpdateRotation(ctx, req.(*UpdateRotationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_RemoveRotation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRotationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).RemoveRotation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_RemoveRotation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).RemoveRotation(ctx, req.(*RemoveRotationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_CreateOverride_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOverrideRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).CreateOverride(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_CreateOverride_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).CreateOverride(ctx, req.(*CreateOverrideRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_DeleteOverride_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteOverrideRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).DeleteOverride(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_DeleteOverride_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).DeleteOverride(ctx, req.(*DeleteOverrideRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_ListOverrides_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOverridesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).ListOverrides(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_ListOverrides_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).ListOverrides(ctx, req.(*ListOverridesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_GetCurrentOnCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentOnCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).GetCurrentOnCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_GetCurrentOnCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).GetCurrentOnCall(ctx, req.(*GetCurrentOnCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_GetOnCallAtTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOnCallAtTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).GetOnCallAtTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_GetOnCallAtTime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).GetOnCallAtTime(ctx, req.(*GetOnCallAtTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_ListUpcomingShifts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUpcomingShiftsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).ListUpcomingShifts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_ListUpcomingShifts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).ListUpcomingShifts(ctx, req.(*ListUpcomingShiftsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_AcknowledgeHandoff_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcknowledgeHandoffRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).AcknowledgeHandoff(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_AcknowledgeHandoff_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).AcknowledgeHandoff(ctx, req.(*AcknowledgeHandoffRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScheduleService_GetHandoffSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHandoffSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScheduleServiceServer).GetHandoffSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScheduleService_GetHandoffSummary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScheduleServiceServer).GetHandoffSummary(ctx, req.(*GetHandoffSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ScheduleService_ServiceDesc is the grpc.ServiceDesc for ScheduleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ScheduleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "alerting.routing.v1.ScheduleService",
	HandlerType: (*ScheduleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSchedule",
			Handler:    _ScheduleService_CreateSchedule_Handler,
		},
		{
			MethodName: "GetSchedule",
			Handler:    _ScheduleService_GetSchedule_Handler,
		},
		{
			MethodName: "ListSchedules",
			Handler:    _ScheduleService_ListSchedules_Handler,
		},
		{
			MethodName: "UpdateSchedule",
			Handler:    _ScheduleService_UpdateSchedule_Handler,
		},
		{
			MethodName: "DeleteSchedule",
			Handler:    _ScheduleService_DeleteSchedule_Handler,
		},
		{
			MethodName: "AddRotation",
			Handler:    _ScheduleService_AddRotation_Handler,
		},
		{
			MethodName: "UpdateRotation",
			Handler:    _ScheduleService_UpdateRotation_Handler,
		},
		{
			MethodName: "RemoveRotation",
			Handler:    _ScheduleService_RemoveRotation_Handler,
		},
		{
			MethodName: "CreateOverride",
			Handler:    _ScheduleService_CreateOverride_Handler,
		},
		{
			MethodName: "DeleteOverride",
			Handler:    _ScheduleService_DeleteOverride_Handler,
		},
		{
			MethodName: "ListOverrides",
			Handler:    _ScheduleService_ListOverrides_Handler,
		},
		{
			MethodName: "GetCurrentOnCall",
			Handler:    _ScheduleService_GetCurrentOnCall_Handler,
		},
		{
			MethodName: "GetOnCallAtTime",
			Handler:    _ScheduleService_GetOnCallAtTime_Handler,
		},
		{
			MethodName: "ListUpcomingShifts",
			Handler:    _ScheduleService_ListUpcomingShifts_Handler,
		},
		{
			MethodName: "AcknowledgeHandoff",
			Handler:    _ScheduleService_AcknowledgeHandoff_Handler,
		},
		{
			MethodName: "GetHandoffSummary",
			Handler:    _ScheduleService_GetHandoffSummary_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "alerting/routing/v1/routing_service.proto",
}

const (
	SiteService_CreateSite_FullMethodName    = "/alerting.routing.v1.SiteService/CreateSite"
	SiteService_GetSite_FullMethodName       = "/alerting.routing.v1.SiteService/GetSite"
	SiteService_ListSites_FullMethodName     = "/alerting.routing.v1.SiteService/ListSites"
	SiteService_UpdateSite_FullMethodName    = "/alerting.routing.v1.SiteService/UpdateSite"
	SiteService_DeleteSite_FullMethodName    = "/alerting.routing.v1.SiteService/DeleteSite"
	SiteService_GetSiteByCode_FullMethodName = "/alerting.routing.v1.SiteService/GetSiteByCode"
)

// SiteServiceClient is the client API for SiteService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SiteServiceClient interface {
	CreateSite(ctx context.Context, in *CreateSiteRequest, opts ...grpc.CallOption) (*Site, error)
	GetSite(ctx context.Context, in *GetSiteRequest, opts ...grpc.CallOption) (*Site, error)
	ListSites(ctx context.Context, in *ListSitesRequest, opts ...grpc.CallOption) (*ListSitesResponse, error)
	UpdateSite(ctx context.Context, in *UpdateSiteRequest, opts ...grpc.CallOption) (*Site, error)
	DeleteSite(ctx context.Context, in *DeleteSiteRequest, opts ...grpc.CallOption) (*DeleteSiteResponse, error)
	// Get site by code (e.g., "IAD1")
	GetSiteByCode(ctx context.Context, in *GetSiteByCodeRequest, opts ...grpc.CallOption) (*Site, error)
}

type siteServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSiteServiceClient(cc grpc.ClientConnInterface) SiteServiceClient {
	return &siteServiceClient{cc}
}

func (c *siteServiceClient) CreateSite(ctx context.Context, in *CreateSiteRequest, opts ...grpc.CallOption) (*Site, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Site)
	err := c.cc.Invoke(ctx, SiteService_CreateSite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteServiceClient) GetSite(ctx context.Context, in *GetSiteRequest, opts ...grpc.CallOption) (*Site, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Site)
	err := c.cc.Invoke(ctx, SiteService_GetSite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteServiceClient) ListSites(ctx context.Context, in *ListSitesRequest, opts ...grpc.CallOption) (*ListSitesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSitesResponse)
	err := c.cc.Invoke(ctx, SiteService_ListSites_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteServiceClient) UpdateSite(ctx context.Context, in *UpdateSiteRequest, opts ...grpc.CallOption) (*Site, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Site)
	err := c.cc.Invoke(ctx, SiteService_UpdateSite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteServiceClient) DeleteSite(ctx context.Context, in *DeleteSiteRequest, opts ...grpc.CallOption) (*DeleteSiteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSiteResponse)
	err := c.cc.Invoke(ctx, SiteService_DeleteSite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *siteServiceClient) GetSiteByCode(ctx context.Context, in *GetSiteByCodeRequest, opts ...grpc.CallOption) (*Site, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Site)
	err := c.cc.Invoke(ctx, SiteService_GetSiteByCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SiteServiceServer is the server API for SiteService service.
// All implementations must embed UnimplementedSiteServiceServer
// for forward compatibility.
type SiteServiceServer interface {
	CreateSite(context.Context, *CreateSiteRequest) (*Site, error)
	GetSite(context.Context, *GetSiteRequest) (*Site, error)
	ListSites(context.Context, *ListSitesRequest) (*ListSitesResponse, error)
	UpdateSite(context.Context, *UpdateSiteRequest) (*Site, error)
	DeleteSite(context.Context, *DeleteSiteRequest) (*DeleteSiteResponse, error)
	// Get site by code (e.g., "IAD1")
	GetSiteByCode(context.Context, *GetSiteByCodeRequest) (*Site, error)
	mustEmbedUnimplementedSiteServiceServer()
}

// UnimplementedSiteServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSiteServiceServer struct{}

func (UnimplementedSiteServiceServer) CreateSite(context.Context, *CreateSiteRequest) (*Site, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSite not implemented")
}
func (UnimplementedSiteServiceServer) GetSite(context.Context, *GetSiteRequest) (*Site, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSite not implemented")
}
func (UnimplementedSiteServiceServer) ListSites(context.Context, *ListSitesRequest) (*ListSitesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSites not implemented")
}
func (UnimplementedSiteServiceServer) UpdateSite(context.Context, *UpdateSiteRequest) (*Site, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSite not implemented")
}
func (UnimplementedSiteServiceServer) DeleteSite(context.Context, *DeleteSiteRequest) (*DeleteSiteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSite not implemented")
}
func (UnimplementedSiteServiceServer) GetSiteByCode(context.Context, *GetSiteByCodeRequest) (*Site, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSiteByCode not implemented")
}
func (UnimplementedSiteServiceServer) mustEmbedUnimplementedSiteServiceServer() {}
func (UnimplementedSiteServiceServer) testEmbeddedByValue()                     {}

// UnsafeSiteServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SiteServiceServer will
// result in compilation errors.
type UnsafeSiteServiceServer interface {
	mustEmbedUnimplementedSiteServiceServer()
}

func RegisterSiteServiceServer(s grpc.ServiceRegistrar, srv SiteServiceServer) {
	// If the following call panics, it indicates UnimplementedSiteServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SiteService_ServiceDesc, srv)
}

func _SiteService_CreateSite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSiteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServiceServer).CreateSite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SiteService_CreateSite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServiceServer).CreateSite(ctx, req.(*CreateSiteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SiteService_GetSite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSiteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServiceServer).GetSite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SiteService_GetSite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServiceServer).GetSite(ctx, req.(*GetSiteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SiteService_ListSites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSitesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServiceServer).ListSites(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SiteService_ListSites_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServiceServer).ListSites(ctx, req.(*ListSitesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SiteService_UpdateSite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSiteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServiceServer).UpdateSite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SiteService_UpdateSite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServiceServer).UpdateSite(ctx, req.(*UpdateSiteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SiteService_DeleteSite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSiteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServiceServer).DeleteSite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SiteService_DeleteSite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServiceServer).DeleteSite(ctx, req.(*DeleteSiteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SiteService_GetSiteByCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSiteByCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SiteServiceServer).GetSiteByCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SiteService_GetSiteByCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SiteServiceServer).GetSiteByCode(ctx, req.(*GetSiteByCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SiteService_ServiceDesc is the grpc.ServiceDesc for SiteService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SiteService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "alerting.routing.v1.SiteService",
	HandlerType: (*SiteServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSite",
			Handler:    _SiteService_CreateSite_Handler,
		},
		{
			MethodName: "GetSite",
			Handler:    _SiteService_GetSite_Handler,
		},
		{
			MethodName: "ListSites",
			Handler:    _SiteService_ListSites_Handler,
		},
		{
			MethodName: "UpdateSite",
			Handler:    _SiteService_UpdateSite_Handler,
		},
		{
			MethodName: "DeleteSite",
			Handler:    _SiteService_DeleteSite_Handler,
		},
		{
			MethodName: "GetSiteByCode",
			Handler:    _SiteService_GetSiteByCode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "alerting/routing/v1/routing_service.proto",
}

const (
	MaintenanceService_CreateMaintenanceWindow_FullMethodName      = "/alerting.routing.v1.MaintenanceService/CreateMaintenanceWindow"
	MaintenanceService_GetMaintenanceWindow_FullMethodName         = "/alerting.routing.v1.MaintenanceService/GetMaintenanceWindow"
	MaintenanceService_ListMaintenanceWindows_FullMethodName       = "/alerting.routing.v1.MaintenanceService/ListMaintenanceWindows"
	MaintenanceService_UpdateMaintenanceWindow_FullMethodName      = "/alerting.routing.v1.MaintenanceService/UpdateMaintenanceWindow"
	MaintenanceService_DeleteMaintenanceWindow_FullMethodName      = "/alerting.routing.v1.MaintenanceService/DeleteMaintenanceWindow"
	MaintenanceService_ListActiveMaintenanceWindows_FullMethodName = "/alerting.routing.v1.MaintenanceService/ListActiveMaintenanceWindows"
	MaintenanceService_CheckAlertMaintenance_FullMethodName        = "/alerting.routing.v1.MaintenanceService/CheckAlertMaintenance"
)

// MaintenanceServiceClient is the client API for MaintenanceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MaintenanceServiceClient interface {
	CreateMaintenanceWindow(ctx context.Context, in *CreateMaintenanceWindowRequest, opts ...grpc.CallOption) (*MaintenanceWindow, error)
	GetMaintenanceWindow(ctx context.Context, in *GetMaintenanceWindowRequest, opts ...grpc.CallOption) (*MaintenanceWindow, error)
	ListMaintenanceWindows(ctx context.Context, in *ListMaintenanceWindowsRequest, opts ...grpc.CallOption) (*ListMaintenanceWindowsResponse, error)
	UpdateMaintenanceWindow(ctx context.Context, in *UpdateMaintenanceWindowRequest, opts ...grpc.CallOption) (*MaintenanceWindow, error)
	DeleteMaintenanceWindow(ctx context.Context, in *DeleteMaintenanceWindowRequest, opts ...grpc.CallOption) (*DeleteMaintenanceWindowResponse, error)
	// Get active maintenance windows
	ListActiveMaintenanceWindows(ctx context.Context, in *ListActiveMaintenanceWindowsRequest, opts ...grpc.CallOption) (*ListMaintenanceWindowsResponse, error)
	// Check if alert is in maintenance
	CheckAlertMaintenance(ctx context.Context, in *CheckAlertMaintenanceRequest, opts ...grpc.CallOption) (*CheckAlertMaintenanceResponse, error)
}

type maintenanceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMaintenanceServiceClient(cc grpc.ClientConnInterface) MaintenanceServiceClient {
	return &maintenanceServiceClient{cc}
}

func (c *maintenanceServiceClient) CreateMaintenanceWindow(ctx context.Context, in *CreateMaintenanceWindowRequest, opts ...grpc.CallOption) (*MaintenanceWindow, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MaintenanceWindow)
	err := c.cc.Invoke(ctx, MaintenanceService_CreateMaintenanceWindow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *maintenanceServiceClient) GetMaintenanceWindow(ctx context.Context, in *GetMaintenanceWindowRequest, opts ...grpc.CallOption) (*MaintenanceWindow, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MaintenanceWindow)
	err := c.cc.Invoke(ctx, MaintenanceService_GetMaintenanceWindow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *maintenanceServiceClient) ListMaintenanceWindows(ctx context.Context, in *ListMaintenanceWindowsRequest, opts ...grpc.CallOption) (*ListMaintenanceWindowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMaintenanceWindowsResponse)
	err := c.cc.Invoke(ctx, MaintenanceService_ListMaintenanceWindows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *maintenanceServiceClient) UpdateMaintenanceWindow(ctx context.Context, in *UpdateMaintenanceWindowRequest, opts ...grpc.CallOption) (*MaintenanceWindow, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MaintenanceWindow)
	err := c.cc.Invoke(ctx, MaintenanceService_UpdateMaintenanceWindow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *maintenanceServiceClient) DeleteMaintenanceWindow(ctx context.Context, in *DeleteMaintenanceWindowRequest, opts ...grpc.CallOption) (*DeleteMaintenanceWindowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMaintenanceWindowResponse)
	err := c.cc.Invoke(ctx, MaintenanceService_DeleteMaintenanceWindow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *maintenanceServiceClient) ListActiveMaintenanceWindows(ctx context.Context, in *ListActiveMaintenanceWindowsRequest, opts ...grpc.CallOption) (*ListMaintenanceWindowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMaintenanceWindowsResponse)
	err := c.cc.Invoke(ctx, MaintenanceService_ListActiveMaintenanceWindows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *maintenanceServiceClient) CheckAlertMaintenance(ctx context.Context, in *CheckAlertMaintenanceRequest, opts ...grpc.CallOption) (*CheckAlertMaintenanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckAlertMaintenanceResponse)
	err := c.cc.Invoke(ctx, MaintenanceService_CheckAlertMaintenance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MaintenanceServiceServer is the server API for MaintenanceService service.
// All implementations must embed UnimplementedMaintenanceServiceServer
// for forward compatibility.
type MaintenanceServiceServer interface {
	CreateMaintenanceWindow(context.Context, *CreateMaintenanceWindowRequest) (*MaintenanceWindow, error)
	GetMaintenanceWindow(context.Context, *GetMaintenanceWindowRequest) (*MaintenanceWindow, error)
	ListMaintenanceWindows(context.Context, *ListMaintenanceWindowsRequest) (*ListMaintenanceWindowsResponse, error)
	UpdateMaintenanceWindow(context.Context, *UpdateMaintenanceWindowRequest) (*MaintenanceWindow, error)
	DeleteMaintenanceWindow(context.Context, *DeleteMaintenanceWindowRequest) (*DeleteMaintenanceWindowResponse, error)
	// Get active maintenance windows
	ListActiveMaintenanceWindows(context.Context, *ListActiveMaintenanceWindowsRequest) (*ListMaintenanceWindowsResponse, error)
	// Check if alert is in maintenance
	CheckAlertMaintenance(context.Context, *CheckAlertMaintenanceRequest) (*CheckAlertMaintenanceResponse, error)
	mustEmbedUnimplementedMaintenanceServiceServer()
}

// UnimplementedMaintenanceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMaintenanceServiceServer struct{}

func (UnimplementedMaintenanceServiceServer) CreateMaintenanceWindow(context.Context, *CreateMaintenanceWindowRequest) (*MaintenanceWindow, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateMaintenanceWindow not implemented")
}
func (UnimplementedMaintenanceServiceServer) GetMaintenanceWindow(context.Context, *GetMaintenanceWindowRequest) (*MaintenanceWindow, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMaintenanceWindow not implemented")
}
func (UnimplementedMaintenanceServiceServer) ListMaintenanceWindows(context.Context, *ListMaintenanceWindowsRequest) (*ListMaintenanceWindowsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListMaintenanceWindows not implemented")
}
func (UnimplementedMaintenanceServiceServer) UpdateMaintenanceWindow(context.Context, *UpdateMaintenanceWindowRequest) (*MaintenanceWindow, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateMaintenanceWindow not implemented")
}
func (UnimplementedMaintenanceServiceServer) DeleteMaintenanceWindow(context.Context, *DeleteMaintenanceWindowRequest) (*DeleteMaintenanceWindowResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteMaintenanceWindow not implemented")
}
func (UnimplementedMaintenanceServiceServer) ListActiveMaintenanceWindows(context.Context, *ListActiveMaintenanceWindowsRequest) (*ListMaintenanceWindowsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListActiveMaintenanceWindows not implemented")
}
func (UnimplementedMaintenanceServiceServer) CheckAlertMaintenance(context.Context, *CheckAlertMaintenanceRequest) (*CheckAlertMaintenanceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckAlertMaintenance not implemented")
}
func (UnimplementedMaintenanceServiceServer) mustEmbedUnimplementedMaintenanceServiceServer() {}
func (UnimplementedMaintenanceServiceServer) testEmbeddedByValue()                            {}

// UnsafeMaintenanceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MaintenanceServiceServer will
// result in compilation errors.
type UnsafeMaintenanceServiceServer interface {
	mustEmbedUnimplementedMaintenanceServiceServer()
}

func RegisterMaintenanceServiceServer(s grpc.ServiceRegistrar, srv MaintenanceServiceServer) {
	// If the following call panics, it indicates UnimplementedMaintenanceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MaintenanceService_ServiceDesc, srv)
}

func _MaintenanceService_CreateMaintenanceWindow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMaintenanceWindowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MaintenanceServiceServer).CreateMaintenanceWindow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MaintenanceService_CreateMaintenanceWindow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MaintenanceServiceServer).CreateMaintenanceWindow(ctx, req.(*CreateMaintenanceWindowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MaintenanceService_GetMaintenanceWindow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMaintenanceWindowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MaintenanceServiceServer).GetMaintenanceWindow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MaintenanceService_GetMaintenanceWindow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MaintenanceServiceServer).GetMaintenanceWindow(ctx, req.(*GetMaintenanceWindowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MaintenanceService_ListMaintenanceWindows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMaintenanceWindowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MaintenanceServiceServer).ListMaintenanceWindows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MaintenanceService_ListMaintenanceWindows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MaintenanceServiceServer).ListMaintenanceWindows(ctx, req.(*ListMaintenanceWindowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MaintenanceService_UpdateMaintenanceWindow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMaintenanceWindowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MaintenanceServiceServer).UpdateMaintenanceWindow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MaintenanceService_UpdateMaintenanceWindow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MaintenanceServiceServer).UpdateMaintenanceWindow(ctx, req.(*UpdateMaintenanceWindowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MaintenanceService_DeleteMaintenanceWindow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMaintenanceWindowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MaintenanceServiceServer).DeleteMaintenanceWindow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MaintenanceService_DeleteMaintenanceWindow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MaintenanceServiceServer).DeleteMaintenanceWindow(ctx, req.(*DeleteMaintenanceWindowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MaintenanceService_ListActiveMaintenanceWindows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListActiveMaintenanceWindowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MaintenanceServiceServer).ListActiveMaintenanceWindows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MaintenanceService_ListActiveMaintenanceWindows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MaintenanceServiceServer).ListActiveMaintenanceWindows(ctx, req.(*ListActiveMaintenanceWindowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MaintenanceService_CheckAlertMaintenance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckAlertMaintenanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MaintenanceServiceServer).CheckAlertMaintenance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MaintenanceService_CheckAlertMaintenance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MaintenanceServiceServer).CheckAlertMaintenance(ctx, req.(*CheckAlertMaintenanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MaintenanceService_ServiceDesc is the grpc.ServiceDesc for MaintenanceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MaintenanceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "alerting.routing.v1.MaintenanceService",
	HandlerType: (*MaintenanceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMaintenanceWindow",
			Handler:    _MaintenanceService_CreateMaintenanceWindow_Handler,
		},
		{
			MethodName: "GetMaintenanceWindow",
			Handler:    _MaintenanceService_GetMaintenanceWindow_Handler,
		},
		{
			MethodName: "ListMaintenanceWindows",
			Handler:    _MaintenanceService_ListMaintenanceWindows_Handler,
		},
		{
			MethodName: "UpdateMaintenanceWindow",
			Handler:    _MaintenanceService_UpdateMaintenanceWindow_Handler,
		},
		{
			MethodName: "DeleteMaintenanceWindow",
			Handler:    _MaintenanceService_DeleteMaintenanceWindow_Handler,
		},
		{
			MethodName: "ListActiveMaintenanceWindows",
			Handler:    _MaintenanceService_ListActiveMaintenanceWindows_Handler,
		},
		{
			MethodName: "CheckAlertMaintenance",
			Handler:    _MaintenanceService_CheckAlertMaintenance_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "alerting/routing/v1/routing_service.proto",
}

const (
	EscalationService_CreateEscalationPolicy_FullMethodName = "/alerting.routing.v1.EscalationService/CreateEscalationPolicy"
	EscalationService_GetEscalationPolicy_FullMethodName    = "/alerting.routing.v1.EscalationService/GetEscalationPolicy"
	EscalationService_ListEscalationPolicies_FullMethodName = "/alerting.routing.v1.EscalationService/ListEscalationPolicies"
	EscalationService_UpdateEscalationPolicy_FullMethodName = "/alerting.routing.v1.EscalationService/UpdateEscalationPolicy"
	EscalationService_DeleteEscalationPolicy_FullMethodName = "/alerting.routing.v1.EscalationService/DeleteEscalationPolicy"
	EscalationService_StartEscalation_FullMethodName        = "/alerting.routing.v1.EscalationService/StartEscalation"
	EscalationService_GetEscalationStatus_FullMethodName    = "/alerting.routing.v1.EscalationService/GetEscalationStatus"
	EscalationService_StopEscalation_FullMethodName         = "/alerting.routing.v1.EscalationService/StopEscalation"
)

// EscalationServiceClient is the client API for EscalationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EscalationServiceClient interface {
	CreateEscalationPolicy(ctx context.Context, in *CreateEscalationPolicyRequest, opts ...grpc.CallOption) (*EscalationPolicy, error)
	GetEscalationPolicy(ctx context.Context, in *GetEscalationPolicyRequest, opts ...grpc.CallOption) (*EscalationPolicy, error)
	ListEscalationPolicies(ctx context.Context, in *ListEscalationPoliciesRequest, opts ...grpc.CallOption) (*ListEscalationPoliciesResponse, error)
	UpdateEscalationPolicy(ctx context.Context, in *UpdateEscalationPolicyRequest, opts ...grpc.CallOption) (*EscalationPolicy, error)
	DeleteEscalationPolicy(ctx context.Context, in *DeleteEscalationPolicyRequest, opts ...grpc.CallOption) (*DeleteEscalationPolicyResponse, error)
	// Escalation execution
	StartEscalation(ctx context.Context, in *StartEscalationRequest, opts ...grpc.CallOption) (*StartEscalationResponse, error)
	GetEscalationStatus(ctx context.Context, in *GetEscalationStatusRequest, opts ...grpc.CallOption) (*EscalationStatus, error)
	StopEscalation(ctx context.Context, in *StopEscalationRequest, opts ...grpc.CallOption) (*StopEscalationResponse, error)
}

type escalationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEscalationServiceClient(cc grpc.ClientConnInterface) EscalationServiceClient {
	return &escalationServiceClient{cc}
}

func (c *escalationServiceClient) CreateEscalationPolicy(ctx context.Context, in *CreateEscalationPolicyRequest, opts ...grpc.CallOption) (*EscalationPolicy, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EscalationPolicy)
	err := c.cc.Invoke(ctx, EscalationService_CreateEscalationPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *escalationServiceClient) GetEscalationPolicy(ctx context.Context, in *GetEscalationPolicyRequest, opts ...grpc.CallOption) (*EscalationPolicy, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EscalationPolicy)
	err := c.cc.Invoke(ctx, EscalationService_GetEscalationPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *escalationServiceClient) ListEscalationPolicies(ctx context.Context, in *ListEscalationPoliciesRequest, opts ...grpc.CallOption) (*ListEscalationPoliciesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListEscalationPoliciesResponse)
	err := c.cc.Invoke(ctx, EscalationService_ListEscalationPolicies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *escalationServiceClient) UpdateEscalationPolicy(ctx context.Context, in *UpdateEscalationPolicyRequest, opts ...grpc.CallOption) (*EscalationPolicy, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EscalationPolicy)
	err := c.cc.Invoke(ctx, EscalationService_UpdateEscalationPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *escalationServiceClient) DeleteEscalationPolicy(ctx context.Context, in *DeleteEscalationPolicyRequest, opts ...grpc.CallOption) (*DeleteEscalationPolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteEscalationPolicyResponse)
	err := c.cc.Invoke(ctx, EscalationService_DeleteEscalationPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *escalationServiceClient) StartEscalation(ctx context.Context, in *StartEscalationRequest, opts ...grpc.CallOption) (*StartEscalationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartEscalationResponse)
	err := c.cc.Invoke(ctx, EscalationService_StartEscalation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *escalationServiceClient) GetEscalationStatus(ctx context.Context, in *GetEscalationStatusRequest, opts ...grpc.CallOption) (*EscalationStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EscalationStatus)
	err := c.cc.Invoke(ctx, EscalationService_GetEscalationStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *escalationServiceClient) StopEscalation(ctx context.Context, in *StopEscalationRequest, opts ...grpc.CallOption) (*StopEscalationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopEscalationResponse)
	err := c.cc.Invoke(ctx, EscalationService_StopEscalation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EscalationServiceServer is the server API for EscalationService service.
// All implementations must embed UnimplementedEscalationServiceServer
// for forward compatibility.
type EscalationServiceServer interface {
	CreateEscalationPolicy(context.Context, *CreateEscalationPolicyRequest) (*EscalationPolicy, error)
	GetEscalationPolicy(context.Context, *GetEscalationPolicyRequest) (*EscalationPolicy, error)
	ListEscalationPolicies(context.Context, *ListEscalationPoliciesRequest) (*ListEscalationPoliciesResponse, error)
	UpdateEscalationPolicy(context.Context, *UpdateEscalationPolicyRequest) (*EscalationPolicy, error)
	DeleteEscalationPolicy(context.Context, *DeleteEscalationPolicyRequest) (*DeleteEscalationPolicyResponse, error)
	// Escalation execution
	StartEscalation(context.Context, *StartEscalationRequest) (*StartEscalationResponse, error)
	GetEscalationStatus(context.Context, *GetEscalationStatusRequest) (*EscalationStatus, error)
	StopEscalation(context.Context, *StopEscalationRequest) (*StopEscalationResponse, error)
	mustEmbedUnimplementedEscalationServiceServer()
}

// UnimplementedEscalationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEscalationServiceServer struct{}

func (UnimplementedEscalationServiceServer) CreateEscalationPolicy(context.Context, *CreateEscalationPolicyRequest) (*EscalationPolicy, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateEscalationPolicy not implemented")
}
func (UnimplementedEscalationServiceServer) GetEscalationPolicy(context.Context, *GetEscalationPolicyRequest) (*EscalationPolicy, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEscalationPolicy not implemented")
}
func (UnimplementedEscalationServiceServer) ListEscalationPolicies(context.Context, *ListEscalationPoliciesRequest) (*ListEscalationPoliciesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListEscalationPolicies not implemented")
}
func (UnimplementedEscalationServiceServer) UpdateEscalationPolicy(context.Context, *UpdateEscalationPolicyRequest) (*EscalationPolicy, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateEscalationPolicy not implemented")
}
func (UnimplementedEscalationServiceServer) DeleteEscalationPolicy(context.Context, *DeleteEscalationPolicyRequest) (*DeleteEscalationPolicyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteEscalationPolicy not implemented")
}
func (UnimplementedEscalationServiceServer) StartEscalation(context.Context, *StartEscalationRequest) (*StartEscalationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartEscalation not implemented")
}
func (UnimplementedEscalationServiceServer) GetEscalationStatus(context.Context, *GetEscalationStatusRequest) (*EscalationStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEscalationStatus not implemented")
}
func (UnimplementedEscalationServiceServer) StopEscalation(context.Context, *StopEscalationRequest) (*StopEscalationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopEscalation not implemented")
}
func (UnimplementedEscalationServiceServer) mustEmbedUnimplementedEscalationServiceServer() {}
func (UnimplementedEscalationServiceServer) testEmbeddedByValue()                           {}

// UnsafeEscalationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EscalationServiceServer will
// result in compilation errors.
type UnsafeEscalationServiceServer interface {
	mustEmbedUnimplementedEscalationServiceServer()
}

func RegisterEscalationServiceServer(s grpc.ServiceRegistrar, srv EscalationServiceServer) {
	// If the following call panics, it indicates UnimplementedEscalationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EscalationService_ServiceDesc, srv)
}

func _EscalationService_CreateEscalationPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEscalationPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EscalationServiceServer).CreateEscalationPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EscalationService_CreateEscalationPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EscalationServiceServer).CreateEscalationPolicy(ctx, req.(*CreateEscalationPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EscalationService_GetEscalationPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEscalationPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EscalationServiceServer).GetEscalationPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EscalationService_GetEscalationPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EscalationServiceServer).GetEscalationPolicy(ctx, req.(*GetEscalationPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EscalationService_ListEscalationPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEscalationPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EscalationServiceServer).ListEscalationPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EscalationService_ListEscalationPolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EscalationServiceServer).ListEscalationPolicies(ctx, req.(*ListEscalationPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EscalationService_UpdateEscalationPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEscalationPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EscalationServiceServer).UpdateEscalationPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EscalationService_UpdateEscalationPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EscalationServiceServer).UpdateEscalationPolicy(ctx, req.(*UpdateEscalationPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EscalationService_DeleteEscalationPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteEscalationPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EscalationServiceServer).DeleteEscalationPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EscalationService_DeleteEscalationPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EscalationServiceServer).DeleteEscalationPolicy(ctx, req.(*DeleteEscalationPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EscalationService_StartEscalation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartEscalationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EscalationServiceServer).StartEscalation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EscalationService_StartEscalation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EscalationServiceServer).StartEscalation(ctx, req.(*StartEscalationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EscalationService_GetEscalationStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEscalationStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EscalationServiceServer).GetEscalationStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EscalationService_GetEscalationStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EscalationServiceServer).GetEscalationStatus(ctx, req.(*GetEscalationStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EscalationService_StopEscalation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopEscalationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EscalationServiceServer).StopEscalation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EscalationService_StopEscalation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EscalationServiceServer).StopEscalation(ctx, req.(*StopEscalationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EscalationService_ServiceDesc is the grpc.ServiceDesc for EscalationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EscalationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "alerting.routing.v1.EscalationService",
	HandlerType: (*EscalationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateEscalationPolicy",
			Handler:    _EscalationService_CreateEscalationPolicy_Handler,
		},
		{
			MethodName: "GetEscalationPolicy",
			Handler:    _EscalationService_GetEscalationPolicy_Handler,
		},
		{
			MethodName: "ListEscalationPolicies",
			Handler:    _EscalationService_ListEscalationPolicies_Handler,
		},
		{
			MethodName: "UpdateEscalationPolicy",
			Handler:    _EscalationService_UpdateEscalationPolicy_Handler,
		},
		{
			MethodName: "DeleteEscalationPolicy",
			Handler:    _EscalationService_DeleteEscalationPolicy_Handler,
		},
		{
			MethodName: "StartEscalation",
			Handler:    _EscalationService_StartEscalation_Handler,
		},
		{
			MethodName: "GetEscalationStatus",
			Handler:    _EscalationService_GetEscalationStatus_Handler,
		},
		{
			MethodName: "StopEscalation",
			Handler:    _EscalationService_StopEscalation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "alerting/routing/v1/routing_service.proto",
}

const (
	CustomerTierService_CreateCustomerTier_FullMethodName  = "/alerting.routing.v1.CustomerTierService/CreateCustomerTier"
	CustomerTierService_GetCustomerTier_FullMethodName     = "/alerting.routing.v1.CustomerTierService/GetCustomerTier"
	CustomerTierService_ListCustomerTiers_FullMethodName   = "/alerting.routing.v1.CustomerTierService/ListCustomerTiers"
	CustomerTierService_UpdateCustomerTier_FullMethodName  = "/alerting.routing.v1.CustomerTierService/UpdateCustomerTier"
	CustomerTierService_DeleteCustomerTier_FullMethodName  = "/alerting.routing.v1.CustomerTierService/DeleteCustomerTier"
	CustomerTierService_ResolveCustomerTier_FullMethodName = "/alerting.routing.v1.CustomerTierService/ResolveCustomerTier"
)

// CustomerTierServiceClient is the client API for CustomerTierService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CustomerTierServiceClient interface {
	CreateCustomerTier(ctx context.Context, in *CreateCustomerTierRequest, opts ...grpc.CallOption) (*CustomerTier, error)
	GetCustomerTier(ctx context.Context, in *GetCustomerTierRequest, opts ...grpc.CallOption) (*CustomerTier, error)
	ListCustomerTiers(ctx context.Context, in *ListCustomerTiersRequest, opts ...grpc.CallOption) (*ListCustomerTiersResponse, error)
	UpdateCustomerTier(ctx context.Context, in *UpdateCustomerTierRequest, opts ...grpc.CallOption) (*CustomerTier, error)
	DeleteCustomerTier(ctx context.Context, in *DeleteCustomerTierRequest, opts ...grpc.CallOption) (*DeleteCustomerTierResponse, error)
	// Resolve customer tier from alert labels
	ResolveCustomerTier(ctx context.Context, in *ResolveCustomerTierRequest, opts ...grpc.CallOption) (*ResolveCustomerTierResponse, error)
}

type customerTierServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCustomerTierServiceClient(cc grpc.ClientConnInterface) CustomerTierServiceClient {
	return &customerTierServiceClient{cc}
}

func (c *customerTierServiceClient) CreateCustomerTier(ctx context.Context, in *CreateCustomerTierRequest, opts ...grpc.CallOption) (*CustomerTier, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CustomerTier)
	err := c.cc.Invoke(ctx, CustomerTierService_CreateCustomerTier_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customerTierServiceClient) GetCustomerTier(ctx context.Context, in *GetCustomerTierRequest, opts ...grpc.CallOption) (*CustomerTier, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CustomerTier)
	err := c.cc.Invoke(ctx, CustomerTierService_GetCustomerTier_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customerTierServiceClient) ListCustomerTiers(ctx context.Context, in *ListCustomerTiersRequest, opts ...grpc.CallOption) (*ListCustomerTiersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCustomerTiersResponse)
	err := c.cc.Invoke(ctx, CustomerTierService_ListCustomerTiers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customerTierServiceClient) UpdateCustomerTier(ctx context.Context, in *UpdateCustomerTierRequest, opts ...grpc.CallOption) (*CustomerTier, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CustomerTier)
	err := c.cc.Invoke(ctx, CustomerTierService_UpdateCustomerTier_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customerTierServiceClient) DeleteCustomerTier(ctx context.Context, in *DeleteCustomerTierRequest, opts ...grpc.CallOption) (*DeleteCustomerTierResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCustomerTierResponse)
	err := c.cc.Invoke(ctx, CustomerTierService_DeleteCustomerTier_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customerTierServiceClient) ResolveCustomerTier(ctx context.Context, in *ResolveCustomerTierRequest, opts ...grpc.CallOption) (*ResolveCustomerTierResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolveCustomerTierResponse)
	err := c.cc.Invoke(ctx, CustomerTierService_ResolveCustomerTier_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomerTierServiceServer is the server API for CustomerTierService service.
// All implementations must embed UnimplementedCustomerTierServiceServer
// for forward compatibility.
type CustomerTierServiceServer interface {
	CreateCustomerTier(context.Context, *CreateCustomerTierRequest) (*CustomerTier, error)
	GetCustomerTier(context.Context, *GetCustomerTierRequest) (*CustomerTier, error)
	ListCustomerTiers(context.Context, *ListCustomerTiersRequest) (*ListCustomerTiersResponse, error)
	UpdateCustomerTier(context.Context, *UpdateCustomerTierRequest) (*CustomerTier, error)
	DeleteCustomerTier(context.Context, *DeleteCustomerTierRequest) (*DeleteCustomerTierResponse, error)
	// Resolve customer tier from alert labels
	ResolveCustomerTier(context.Context, *ResolveCustomerTierRequest) (*ResolveCustomerTierResponse, error)
	mustEmbedUnimplementedCustomerTierServiceServer()
}

// UnimplementedCustomerTierServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCustomerTierServiceServer struct{}

func (UnimplementedCustomerTierServiceServer) CreateCustomerTier(context.Context, *CreateCustomerTierRequest) (*CustomerTier, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateCustomerTier not implemented")
}
func (UnimplementedCustomerTierServiceServer) GetCustomerTier(context.Context, *GetCustomerTierRequest) (*CustomerTier, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCustomerTier not implemented")
}
func (UnimplementedCustomerTierServiceServer) ListCustomerTiers(context.Context, *ListCustomerTiersRequest) (*ListCustomerTiersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCustomerTiers not implemented")
}
func (UnimplementedCustomerTierServiceServer) UpdateCustomerTier(context.Context, *UpdateCustomerTierRequest) (*CustomerTier, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateCustomerTier not implemented")
}
func (UnimplementedCustomerTierServiceServer) DeleteCustomerTier(context.Context, *DeleteCustomerTierRequest) (*DeleteCustomerTierResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteCustomerTier not implemented")
}
func (UnimplementedCustomerTierServiceServer) ResolveCustomerTier(context.Context, *ResolveCustomerTierRequest) (*ResolveCustomerTierResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolveCustomerTier not implemented")
}
func (UnimplementedCustomerTierServiceServer) mustEmbedUnimplementedCustomerTierServiceServer() {}
func (UnimplementedCustomerTierServiceServer) testEmbeddedByValue()                             {}

// UnsafeCustomerTierServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CustomerTierServiceServer will
// result in compilation errors.
type UnsafeCustomerTierServiceServer interface {
	mustEmbedUnimplementedCustomerTierServiceServer()
}

func RegisterCustomerTierServiceServer(s grpc.ServiceRegistrar, srv CustomerTierServiceServer) {
	// If the following call panics, it indicates UnimplementedCustomerTierServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CustomerTierService_ServiceDesc, srv)
}

func _CustomerTierService_CreateCustomerTier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCustomerTierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerTierServiceServer).CreateCustomerTier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomerTierService_CreateCustomerTier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerTierServiceServer).CreateCustomerTier(ctx, req.(*CreateCustomerTierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomerTierService_GetCustomerTier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCustomerTierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerTierServiceServer).GetCustomerTier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomerTierService_GetCustomerTier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerTierServiceServer).GetCustomerTier(ctx, req.(*GetCustomerTierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomerTierService_ListCustomerTiers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCustomerTiersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerTierServiceServer).ListCustomerTiers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomerTierService_ListCustomerTiers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerTierServiceServer).ListCustomerTiers(ctx, req.(*ListCustomerTiersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomerTierService_UpdateCustomerTier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCustomerTierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerTierServiceServer).UpdateCustomerTier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomerTierService_UpdateCustomerTier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerTierServiceServer).UpdateCustomerTier(ctx, req.(*UpdateCustomerTierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomerTierService_DeleteCustomerTier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCustomerTierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerTierServiceServer).DeleteCustomerTier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomerTierService_DeleteCustomerTier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerTierServiceServer).DeleteCustomerTier(ctx, req.(*DeleteCustomerTierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomerTierService_ResolveCustomerTier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveCustomerTierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerTierServiceServer).ResolveCustomerTier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomerTierService_ResolveCustomerTier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerTierServiceServer).ResolveCustomerTier(ctx, req.(*ResolveCustomerTierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CustomerTierService_ServiceDesc is the grpc.ServiceDesc for CustomerTierService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CustomerTierService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "alerting.routing.v1.CustomerTierService",
	HandlerType: (*CustomerTierServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCustomerTier",
			Handler:    _CustomerTierService_CreateCustomerTier_Handler,
		},
		{
			MethodName: "GetCustomerTier",
			Handler:    _CustomerTierService_GetCustomerTier_Handler,
		},
		{
			MethodName: "ListCustomerTiers",
			Handler:    _CustomerTierService_ListCustomerTiers_Handler,
		},
		{
			MethodName: "UpdateCustomerTier",
			Handler:    _CustomerTierService_UpdateCustomerTier_Handler,
		},
		{
			MethodName: "DeleteCustomerTier",
			Handler:    _CustomerTierService_DeleteCustomerTier_Handler,
		},
		{
			MethodName: "ResolveCustomerTier",
			Handler:    _CustomerTierService_ResolveCustomerTier_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "alerting/routing/v1/routing_service.proto",
}

const (
	CarrierService_CreateCarrier_FullMethodName   = "/alerting.routing.v1.CarrierService/CreateCarrier"
	CarrierService_GetCarrier_FullMethodName      = "/alerting.routing.v1.CarrierService/GetCarrier"
	CarrierService_ListCarriers_FullMethodName    = "/alerting.routing.v1.CarrierService/ListCarriers"
	CarrierService_UpdateCarrier_FullMethodName   = "/alerting.routing.v1.CarrierService/UpdateCarrier"
	CarrierService_DeleteCarrier_FullMethodName   = "/alerting.routing.v1.CarrierService/DeleteCarrier"
	CarrierService_GetCarrierByASN_FullMethodName = "/alerting.routing.v1.CarrierService/GetCarrierByASN"
)

// CarrierServiceClient is the client API for CarrierService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CarrierServiceClient interface {
	CreateCarrier(ctx context.Context, in *CreateCarrierRequest, opts ...grpc.CallOption) (*CarrierConfig, error)
	GetCarrier(ctx context.Context, in *GetCarrierRequest, opts ...grpc.CallOption) (*CarrierConfig, error)
	ListCarriers(ctx context.Context, in *ListCarriersRequest, opts ...grpc.CallOption) (*ListCarriersResponse, error)
	UpdateCarrier(ctx context.Context, in *UpdateCarrierRequest, opts ...grpc.CallOption) (*CarrierConfig, error)
	DeleteCarrier(ctx context.Context, in *DeleteCarrierRequest, opts ...grpc.CallOption) (*DeleteCarrierResponse, error)
	// Get carrier by ASN
	GetCarrierByASN(ctx context.Context, in *GetCarrierByASNRequest, opts ...grpc.CallOption) (*CarrierConfig, error)
}

type carrierServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCarrierServiceClient(cc grpc.ClientConnInterface) CarrierServiceClient {
	return &carrierServiceClient{cc}
}

func (c *carrierServiceClient) CreateCarrier(ctx context.Context, in *CreateCarrierRequest, opts ...grpc.CallOption) (*CarrierConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CarrierConfig)
	err := c.cc.Invoke(ctx, CarrierService_CreateCarrier_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carrierServiceClient) GetCarrier(ctx context.Context, in *GetCarrierRequest, opts ...grpc.CallOption) (*CarrierConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CarrierConfig)
	err := c.cc.Invoke(ctx, CarrierService_GetCarrier_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carrierServiceClient) ListCarriers(ctx context.Context, in *ListCarriersRequest, opts ...grpc.CallOption) (*ListCarriersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCarriersResponse)
	err := c.cc.Invoke(ctx, CarrierService_ListCarriers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carrierServiceClient) UpdateCarrier(ctx context.Context, in *UpdateCarrierRequest, opts ...grpc.CallOption) (*CarrierConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CarrierConfig)
	err := c.cc.Invoke(ctx, CarrierService_UpdateCarrier_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carrierServiceClient) DeleteCarrier(ctx context.Context, in *DeleteCarrierRequest, opts ...grpc.CallOption) (*DeleteCarrierResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCarrierResponse)
	err := c.cc.Invoke(ctx, CarrierService_DeleteCarrier_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *carrierServiceClient) GetCarrierByASN(ctx context.Context, in *GetCarrierByASNRequest, opts ...grpc.CallOption) (*CarrierConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CarrierConfig)
	err := c.cc.Invoke(ctx, CarrierService_GetCarrierByASN_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CarrierServiceServer is the server API for CarrierService service.
// All implementations must embed UnimplementedCarrierServiceServer
// for forward compatibility.
type CarrierServiceServer interface {
	CreateCarrier(context.Context, *CreateCarrierRequest) (*CarrierConfig, error)
	GetCarrier(context.Context, *GetCarrierRequest) (*CarrierConfig, error)
	ListCarriers(context.Context, *ListCarriersRequest) (*ListCarriersResponse, error)
	UpdateCarrier(context.Context, *UpdateCarrierRequest) (*CarrierConfig, error)
	DeleteCarrier(context.Context, *DeleteCarrierRequest) (*DeleteCarrierResponse, error)
	// Get carrier by ASN
	GetCarrierByASN(context.Context, *GetCarrierByASNRequest) (*CarrierConfig, error)
	mustEmbedUnimplementedCarrierServiceServer()
}

// UnimplementedCarrierServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCarrierServiceServer struct{}

func (UnimplementedCarrierServiceServer) CreateCarrier(context.Context, *CreateCarrierRequest) (*CarrierConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateCarrier not implemented")
}
func (UnimplementedCarrierServiceServer) GetCarrier(context.Context, *GetCarrierRequest) (*CarrierConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCarrier not implemented")
}
func (UnimplementedCarrierServiceServer) ListCarriers(context.Context, *ListCarriersRequest) (*ListCarriersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCarriers not implemented")
}
func (UnimplementedCarrierServiceServer) UpdateCarrier(context.Context, *UpdateCarrierRequest) (*CarrierConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateCarrier not implemented")
}
func (UnimplementedCarrierServiceServer) DeleteCarrier(context.Context, *DeleteCarrierRequest) (*DeleteCarrierResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteCarrier not implemented")
}
func (UnimplementedCarrierServiceServer) GetCarrierByASN(context.Context, *GetCarrierByASNRequest) (*CarrierConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCarrierByASN not implemented")
}
func (UnimplementedCarrierServiceServer) mustEmbedUnimplementedCarrierServiceServer() {}
func (UnimplementedCarrierServiceServer) testEmbeddedByValue()                        {}

// UnsafeCarrierServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CarrierServiceServer will
// result in compilation errors.
type UnsafeCarrierServiceServer interface {
	mustEmbedUnimplementedCarrierServiceServer()
}

func RegisterCarrierServiceServer(s grpc.ServiceRegistrar, srv CarrierServiceServer) {
	// If the following call panics, it indicates UnimplementedCarrierServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CarrierService_ServiceDesc, srv)
}

func _CarrierService_CreateCarrier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCarrierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarrierServiceServer).CreateCarrier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CarrierService_CreateCarrier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarrierServiceServer).CreateCarrier(ctx, req.(*CreateCarrierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CarrierService_GetCarrier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCarrierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarrierServiceServer).GetCarrier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CarrierService_GetCarrier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarrierServiceServer).GetCarrier(ctx, req.(*GetCarrierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CarrierService_ListCarriers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCarriersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarrierServiceServer).ListCarriers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CarrierService_ListCarriers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarrierServiceServer).ListCarriers(ctx, req.(*ListCarriersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CarrierService_UpdateCarrier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCarrierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarrierServiceServer).UpdateCarrier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CarrierService_UpdateCarrier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarrierServiceServer).UpdateCarrier(ctx, req.(*UpdateCarrierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CarrierService_DeleteCarrier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCarrierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarrierServiceServer).DeleteCarrier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CarrierService_DeleteCarrier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarrierServiceServer).DeleteCarrier(ctx, req.(*DeleteCarrierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CarrierService_GetCarrierByASN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCarrierByASNRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CarrierServiceServer).GetCarrierByASN(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CarrierService_GetCarrierByASN_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CarrierServiceServer).GetCarrierByASN(ctx, req.(*GetCarrierByASNRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CarrierService_ServiceDesc is the grpc.ServiceDesc for CarrierService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CarrierService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "alerting.routing.v1.CarrierService",
	HandlerType: (*CarrierServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCarrier",
			Handler:    _CarrierService_CreateCarrier_Handler,
		},
		{
			MethodName: "GetCarrier",
			Handler:    _CarrierService_GetCarrier_Handler,
		},
		{
			MethodName: "ListCarriers",
			Handler:    _CarrierService_ListCarriers_Handler,
		},
		{
			MethodName: "UpdateCarrier",
			Handler:    _CarrierService_UpdateCarrier_Handler,
		},
		{
			MethodName: "DeleteCarrier",
			Handler:    _CarrierService_DeleteCarrier_Handler,
		},
		{
			MethodName: "GetCarrierByASN",
			Handler:    _CarrierService_GetCarrierByASN_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "alerting/routing/v1/routing_service.proto",
}

const (
	RateLimitService_CreateRateLimitConfig_FullMethodName         = "/alerting.routing.v1.RateLimitService/CreateRateLimitConfig"
	RateLimitService_GetRateLimitConfig_FullMethodName            = "/alerting.routing.v1.RateLimitService/GetRateLimitConfig"
	RateLimitService_GetRateLimitConfigByServiceID_FullMethodName = "/alerting.routing.v1.RateLimitService/GetRateLimitConfigByServiceID"
	RateLimitService_ListRateLimitConfigs_FullMethodName          = "/alerting.routing.v1.RateLimitService/ListRateLimitConfigs"
	RateLimitService_UpdateRateLimitConfig_FullMethodName         = "/alerting.routing.v1.RateLimitService/UpdateRateLimitConfig"
	RateLimitService_DeleteRateLimitConfig_FullMethodName         = "/alerting.routing.v1.RateLimitService/DeleteRateLimitConfig"
)

// RateLimitServiceClient is the client API for RateLimitService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// RateLimitService provides CRUD operations for per-service rate limit configuration
type RateLimitServiceClient interface {
	// Create a new rate limit config for a service
	CreateRateLimitConfig(ctx context.Context, in *CreateRateLimitConfigRequest, opts ...grpc.CallOption) (*RateLimitConfig, error)
	// Get a rate limit config by ID
	GetRateLimitConfig(ctx context.Context, in *GetRateLimitConfigRequest, opts ...grpc.CallOption) (*RateLimitConfig, error)
	// Get a rate limit config by service ID
	GetRateLimitConfigByServiceID(ctx context.Context, in *GetRateLimitConfigByServiceIDRequest, opts ...grpc.CallOption) (*RateLimitConfig, error)
	// List rate limit configs with pagination
	ListRateLimitConfigs(ctx context.Context, in *ListRateLimitConfigsRequest, opts ...grpc.CallOption) (*ListRateLimitConfigsResponse, error)
	// Update a rate limit config
	UpdateRateLimitConfig(ctx context.Context, in *UpdateRateLimitConfigRequest, opts ...grpc.CallOption) (*RateLimitConfig, error)
	// Delete a rate limit config
	DeleteRateLimitConfig(ctx context.Context, in *DeleteRateLimitConfigRequest, opts ...grpc.CallOption) (*DeleteRateLimitConfigResponse, error)
}

type rateLimitServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRateLimitServiceClient(cc grpc.ClientConnInterface) RateLimitServiceClient {
	return &rateLimitServiceClient{cc}
}

func (c *rateLimitServiceClient) CreateRateLimitConfig(ctx context.Context, in *CreateRateLimitConfigRequest, opts ...grpc.CallOption) (*RateLimitConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RateLimitConfig)
	err := c.cc.Invoke(ctx, RateLimitService_CreateRateLimitConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) GetRateLimitConfig(ctx context.Context, in *GetRateLimitConfigRequest, opts ...grpc.CallOption) (*RateLimitConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RateLimitConfig)
	err := c.cc.Invoke(ctx, RateLimitService_GetRateLimitConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) GetRateLimitConfigByServiceID(ctx context.Context, in *GetRateLimitConfigByServiceIDRequest, opts ...grpc.CallOption) (*RateLimitConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RateLimitConfig)
	err := c.cc.Invoke(ctx, RateLimitService_GetRateLimitConfigByServiceID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) ListRateLimitConfigs(ctx context.Context, in *ListRateLimitConfigsRequest, opts ...grpc.CallOption) (*ListRateLimitConfigsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRateLimitConfigsResponse)
	err := c.cc.Invoke(ctx, RateLimitService_ListRateLimitConfigs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) UpdateRateLimitConfig(ctx context.Context, in *UpdateRateLimitConfigRequest, opts ...grpc.CallOption) (*RateLimitConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RateLimitConfig)
	err := c.cc.Invoke(ctx, RateLimitService_UpdateRateLimitConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rateLimitServiceClient) DeleteRateLimitConfig(ctx context.Context, in *DeleteRateLimitConfigRequest, opts ...grpc.CallOption) (*DeleteRateLimitConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteRateLimitConfigResponse)
	err := c.cc.Invoke(ctx, RateLimitService_DeleteRateLimitConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RateLimitServiceServer is the server API for RateLimitService service.
// All implementations must embed UnimplementedRateLimitServiceServer
// for forward compatibility.
//
// RateLimitService provides CRUD operations for per-service rate limit configuration
type RateLimitServiceServer interface {
	// Create a new rate limit config for a service
	CreateRateLimitConfig(context.Context, *CreateRateLimitConfigRequest) (*RateLimitConfig, error)
	// Get a rate limit config by ID
	GetRateLimitConfig(context.Context, *GetRateLimitConfigRequest) (*RateLimitConfig, error)
	// Get a rate limit config by service ID
	GetRateLimitConfigByServiceID(context.Context, *GetRateLimitConfigByServiceIDRequest) (*RateLimitConfig, error)
	// List rate limit configs with pagination
	ListRateLimitConfigs(context.Context, *ListRateLimitConfigsRequest) (*ListRateLimitConfigsResponse, error)
	// Update a rate limit config
	UpdateRateLimitConfig(context.Context, *UpdateRateLimitConfigRequest) (*RateLimitConfig, error)
	// Delete a rate limit config
	DeleteRateLimitConfig(context.Context, *DeleteRateLimitConfigRequest) (*DeleteRateLimitConfigResponse, error)
	mustEmbedUnimplementedRateLimitServiceServer()
}

// UnimplementedRateLimitServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRateLimitServiceServer struct{}

func (UnimplementedRateLimitServiceServer) CreateRateLimitConfig(context.Context, *CreateRateLimitConfigRequest) (*RateLimitConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateRateLimitConfig not implemented")
}
func (UnimplementedRateLimitServiceServer) GetRateLimitConfig(context.Context, *GetRateLimitConfigRequest) (*RateLimitConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRateLimitConfig not implemented")
}
func (UnimplementedRateLimitServiceServer) GetRateLimitConfigByServiceID(context.Context, *GetRateLimitConfigByServiceIDRequest) (*RateLimitConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRateLimitConfigByServiceID not implemented")
}
func (UnimplementedRateLimitServiceServer) ListRateLimitConfigs(context.Context, *ListRateLimitConfigsRequest) (*ListRateLimitConfigsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRateLimitConfigs not implemented")
}
func (UnimplementedRateLimitServiceServer) UpdateRateLimitConfig(context.Context, *UpdateRateLimitConfigRequest) (*RateLimitConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateRateLimitConfig not implemented")
}
func (UnimplementedRateLimitServiceServer) DeleteRateLimitConfig(context.Context, *DeleteRateLimitConfigRequest) (*DeleteRateLimitConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteRateLimitConfig not implemented")
}
func (UnimplementedRateLimitServiceServer) mustEmbedUnimplementedRateLimitServiceServer() {}
func (UnimplementedRateLimitServiceServer) testEmbeddedByValue()                          {}

// UnsafeRateLimitServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RateLimitServiceServer will
// result in compilation errors.
type UnsafeRateLimitServiceServer interface {
	mustEmbedUnimplementedRateLimitServiceServer()
}

func RegisterRateLimitServiceServer(s grpc.ServiceRegistrar, srv RateLimitServiceServer) {
	// If the following call panics, it indicates UnimplementedRateLimitServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RateLimitService_ServiceDesc, srv)
}

func _RateLimitService_CreateRateLimitConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRateLimitConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).CreateRateLimitConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_CreateRateLimitConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).CreateRateLimitConfig(ctx, req.(*CreateRateLimitConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_GetRateLimitConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRateLimitConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).GetRateLimitConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_GetRateLimitConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).GetRateLimitConfig(ctx, req.(*GetRateLimitConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_GetRateLimitConfigByServiceID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRateLimitConfigByServiceIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).GetRateLimitConfigByServiceID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_GetRateLimitConfigByServiceID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).GetRateLimitConfigByServiceID(ctx, req.(*GetRateLimitConfigByServiceIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_ListRateLimitConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRateLimitConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).ListRateLimitConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_ListRateLimitConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).ListRateLimitConfigs(ctx, req.(*ListRateLimitConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_UpdateRateLimitConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRateLimitConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).UpdateRateLimitConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_UpdateRateLimitConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).UpdateRateLimitConfig(ctx, req.(*UpdateRateLimitConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RateLimitService_DeleteRateLimitConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRateLimitConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RateLimitServiceServer).DeleteRateLimitConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RateLimitService_DeleteRateLimitConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RateLimitServiceServer).DeleteRateLimitConfig(ctx, req.(*DeleteRateLimitConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RateLimitService_ServiceDesc is the grpc.ServiceDesc for RateLimitService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RateLimitService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "alerting.routing.v1.RateLimitService",
	HandlerType: (*RateLimitServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRateLimitConfig",
			Handler:    _RateLimitService_CreateRateLimitConfig_Handler,
		},
		{
			MethodName: "GetRateLimitConfig",
			Handler:    _RateLimitService_GetRateLimitConfig_Handler,
		},
		{
			MethodName: "GetRateLimitConfigByServiceID",
			Handler:    _RateLimitService_GetRateLimitConfigByServiceID_Handler,
		},
		{
			MethodName: "ListRateLimitConfigs",
			Handler:    _RateLimitService_ListRateLimitConfigs_Handler,
		},
		{
			MethodName: "UpdateRateLimitConfig",
			Handler:    _RateLimitService_UpdateRateLimitConfig_Handler,
		},
		{
			MethodName: "DeleteRateLimitConfig",
			Handler:    _RateLimitService_DeleteRateLimitConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "alerting/routing/v1/routing_service.proto",
}
