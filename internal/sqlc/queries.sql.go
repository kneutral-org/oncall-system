// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addTeamMember = `-- name: AddTeamMember :exec
INSERT INTO team_members (team_id, user_id, role, preferences)
VALUES ($1, $2, $3, $4)
ON CONFLICT (team_id, user_id)
DO UPDATE SET role = EXCLUDED.role, preferences = EXCLUDED.preferences
`

type AddTeamMemberParams struct {
	TeamID      uuid.UUID `json:"teamId"`
	UserID      uuid.UUID `json:"userId"`
	Role        TeamRole  `json:"role"`
	Preferences []byte    `json:"preferences"`
}

func (q *Queries) AddTeamMember(ctx context.Context, arg AddTeamMemberParams) error {
	_, err := q.db.Exec(ctx, addTeamMember,
		arg.TeamID,
		arg.UserID,
		arg.Role,
		arg.Preferences,
	)
	return err
}

const createRoutingRule = `-- name: CreateRoutingRule :one
INSERT INTO routing_rules (
    name,
    description,
    priority,
    enabled,
    conditions,
    actions,
    terminal,
    time_condition,
    tags,
    created_by,
    updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $10
)
RETURNING id, name, description, priority, enabled, conditions, actions, terminal, time_condition, tags, created_by, created_at, updated_by, updated_at
`

type CreateRoutingRuleParams struct {
	Name          string          `json:"name"`
	Description   pgtype.Text     `json:"description"`
	Priority      int32           `json:"priority"`
	Enabled       bool            `json:"enabled"`
	Conditions    json.RawMessage `json:"conditions"`
	Actions       json.RawMessage `json:"actions"`
	Terminal      bool            `json:"terminal"`
	TimeCondition []byte          `json:"timeCondition"`
	Tags          []string        `json:"tags"`
	CreatedBy     pgtype.UUID     `json:"createdBy"`
}

func (q *Queries) CreateRoutingRule(ctx context.Context, arg CreateRoutingRuleParams) (RoutingRule, error) {
	row := q.db.QueryRow(ctx, createRoutingRule,
		arg.Name,
		arg.Description,
		arg.Priority,
		arg.Enabled,
		arg.Conditions,
		arg.Actions,
		arg.Terminal,
		arg.TimeCondition,
		arg.Tags,
		arg.CreatedBy,
	)
	var i RoutingRule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Priority,
		&i.Enabled,
		&i.Conditions,
		&i.Actions,
		&i.Terminal,
		&i.TimeCondition,
		&i.Tags,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
	)
	return i, err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO teams (
    name,
    description,
    default_escalation_policy_id,
    default_channel,
    assigned_sites,
    assigned_pops,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, name, description, default_escalation_policy_id, default_channel, assigned_sites, assigned_pops, metadata, created_at, updated_at
`

type CreateTeamParams struct {
	Name                      string          `json:"name"`
	Description               pgtype.Text     `json:"description"`
	DefaultEscalationPolicyID pgtype.UUID     `json:"defaultEscalationPolicyId"`
	DefaultChannel            []byte          `json:"defaultChannel"`
	AssignedSites             []string        `json:"assignedSites"`
	AssignedPops              []string        `json:"assignedPops"`
	Metadata                  json.RawMessage `json:"metadata"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (Team, error) {
	row := q.db.QueryRow(ctx, createTeam,
		arg.Name,
		arg.Description,
		arg.DefaultEscalationPolicyID,
		arg.DefaultChannel,
		arg.AssignedSites,
		arg.AssignedPops,
		arg.Metadata,
	)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.DefaultEscalationPolicyID,
		&i.DefaultChannel,
		&i.AssignedSites,
		&i.AssignedPops,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRoutingRule = `-- name: DeleteRoutingRule :exec
DELETE FROM routing_rules
WHERE id = $1
`

func (q *Queries) DeleteRoutingRule(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRoutingRule, id)
	return err
}

const deleteTeam = `-- name: DeleteTeam :exec
DELETE FROM teams
WHERE id = $1
`

func (q *Queries) DeleteTeam(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTeam, id)
	return err
}

const getEnabledRulesByPriority = `-- name: GetEnabledRulesByPriority :many
SELECT id, name, description, priority, enabled, conditions, actions, terminal, time_condition, tags, created_by, created_at, updated_by, updated_at FROM routing_rules
WHERE enabled = true
ORDER BY priority ASC, created_at ASC
`

func (q *Queries) GetEnabledRulesByPriority(ctx context.Context) ([]RoutingRule, error) {
	rows, err := q.db.Query(ctx, getEnabledRulesByPriority)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RoutingRule{}
	for rows.Next() {
		var i RoutingRule
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Priority,
			&i.Enabled,
			&i.Conditions,
			&i.Actions,
			&i.Terminal,
			&i.TimeCondition,
			&i.Tags,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedBy,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoutingRule = `-- name: GetRoutingRule :one
SELECT id, name, description, priority, enabled, conditions, actions, terminal, time_condition, tags, created_by, created_at, updated_by, updated_at FROM routing_rules
WHERE id = $1
`

func (q *Queries) GetRoutingRule(ctx context.Context, id uuid.UUID) (RoutingRule, error) {
	row := q.db.QueryRow(ctx, getRoutingRule, id)
	var i RoutingRule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Priority,
		&i.Enabled,
		&i.Conditions,
		&i.Actions,
		&i.Terminal,
		&i.TimeCondition,
		&i.Tags,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoutingRulesByTags = `-- name: GetRoutingRulesByTags :many
SELECT id, name, description, priority, enabled, conditions, actions, terminal, time_condition, tags, created_by, created_at, updated_by, updated_at FROM routing_rules
WHERE tags && $1::text[]
ORDER BY priority ASC, created_at ASC
`

func (q *Queries) GetRoutingRulesByTags(ctx context.Context, tags []string) ([]RoutingRule, error) {
	rows, err := q.db.Query(ctx, getRoutingRulesByTags, tags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RoutingRule{}
	for rows.Next() {
		var i RoutingRule
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Priority,
			&i.Enabled,
			&i.Conditions,
			&i.Actions,
			&i.Terminal,
			&i.TimeCondition,
			&i.Tags,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedBy,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeam = `-- name: GetTeam :one
SELECT id, name, description, default_escalation_policy_id, default_channel, assigned_sites, assigned_pops, metadata, created_at, updated_at FROM teams
WHERE id = $1
`

func (q *Queries) GetTeam(ctx context.Context, id uuid.UUID) (Team, error) {
	row := q.db.QueryRow(ctx, getTeam, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.DefaultEscalationPolicyID,
		&i.DefaultChannel,
		&i.AssignedSites,
		&i.AssignedPops,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamMember = `-- name: GetTeamMember :one
SELECT team_id, user_id, role, preferences, joined_at FROM team_members
WHERE team_id = $1 AND user_id = $2
`

type GetTeamMemberParams struct {
	TeamID uuid.UUID `json:"teamId"`
	UserID uuid.UUID `json:"userId"`
}

func (q *Queries) GetTeamMember(ctx context.Context, arg GetTeamMemberParams) (TeamMember, error) {
	row := q.db.QueryRow(ctx, getTeamMember, arg.TeamID, arg.UserID)
	var i TeamMember
	err := row.Scan(
		&i.TeamID,
		&i.UserID,
		&i.Role,
		&i.Preferences,
		&i.JoinedAt,
	)
	return i, err
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT team_id, user_id, role, preferences, joined_at FROM team_members
WHERE team_id = $1
ORDER BY joined_at ASC
`

func (q *Queries) GetTeamMembers(ctx context.Context, teamID uuid.UUID) ([]TeamMember, error) {
	rows, err := q.db.Query(ctx, getTeamMembers, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TeamMember{}
	for rows.Next() {
		var i TeamMember
		if err := rows.Scan(
			&i.TeamID,
			&i.UserID,
			&i.Role,
			&i.Preferences,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsByEscalationPolicy = `-- name: GetTeamsByEscalationPolicy :many
SELECT id, name, description, default_escalation_policy_id, default_channel, assigned_sites, assigned_pops, metadata, created_at, updated_at FROM teams
WHERE default_escalation_policy_id = $1
ORDER BY name ASC
`

func (q *Queries) GetTeamsByEscalationPolicy(ctx context.Context, policyID pgtype.UUID) ([]Team, error) {
	rows, err := q.db.Query(ctx, getTeamsByEscalationPolicy, policyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.DefaultEscalationPolicyID,
			&i.DefaultChannel,
			&i.AssignedSites,
			&i.AssignedPops,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTeams = `-- name: GetUserTeams :many
SELECT t.id, t.name, t.description, t.default_escalation_policy_id, t.default_channel, t.assigned_sites, t.assigned_pops, t.metadata, t.created_at, t.updated_at FROM teams t
INNER JOIN team_members tm ON t.id = tm.team_id
WHERE tm.user_id = $1
ORDER BY t.name ASC
`

func (q *Queries) GetUserTeams(ctx context.Context, userID uuid.UUID) ([]Team, error) {
	rows, err := q.db.Query(ctx, getUserTeams, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.DefaultEscalationPolicyID,
			&i.DefaultChannel,
			&i.AssignedSites,
			&i.AssignedPops,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoutingRules = `-- name: ListRoutingRules :many
SELECT id, name, description, priority, enabled, conditions, actions, terminal, time_condition, tags, created_by, created_at, updated_by, updated_at FROM routing_rules
WHERE
    (COALESCE(cardinality($1::boolean[]), 0) = 0 OR enabled = ANY($1::boolean[]))
    AND (COALESCE(cardinality($2::text[]), 0) = 0 OR tags && $2::text[])
ORDER BY priority ASC, created_at ASC
LIMIT $4 OFFSET $3
`

type ListRoutingRulesParams struct {
	EnabledFilter []bool   `json:"enabledFilter"`
	TagsFilter    []string `json:"tagsFilter"`
	Off           int32    `json:"off"`
	Lim           int32    `json:"lim"`
}

func (q *Queries) ListRoutingRules(ctx context.Context, arg ListRoutingRulesParams) ([]RoutingRule, error) {
	rows, err := q.db.Query(ctx, listRoutingRules,
		arg.EnabledFilter,
		arg.TagsFilter,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RoutingRule{}
	for rows.Next() {
		var i RoutingRule
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Priority,
			&i.Enabled,
			&i.Conditions,
			&i.Actions,
			&i.Terminal,
			&i.TimeCondition,
			&i.Tags,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedBy,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoutingRulesCount = `-- name: ListRoutingRulesCount :one
SELECT COUNT(*) FROM routing_rules
WHERE
    (COALESCE(cardinality($1::boolean[]), 0) = 0 OR enabled = ANY($1::boolean[]))
    AND (COALESCE(cardinality($2::text[]), 0) = 0 OR tags && $2::text[])
`

type ListRoutingRulesCountParams struct {
	EnabledFilter []bool   `json:"enabledFilter"`
	TagsFilter    []string `json:"tagsFilter"`
}

func (q *Queries) ListRoutingRulesCount(ctx context.Context, arg ListRoutingRulesCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, listRoutingRulesCount, arg.EnabledFilter, arg.TagsFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listTeams = `-- name: ListTeams :many
SELECT id, name, description, default_escalation_policy_id, default_channel, assigned_sites, assigned_pops, metadata, created_at, updated_at FROM teams
WHERE
    (COALESCE(NULLIF($1, ''), '') = '' OR name ILIKE '%' || $1 || '%')
    AND (COALESCE(cardinality($2::text[]), 0) = 0 OR assigned_sites && $2::text[])
    AND (COALESCE(cardinality($3::text[]), 0) = 0 OR assigned_pops && $3::text[])
ORDER BY name ASC
LIMIT $5 OFFSET $4
`

type ListTeamsParams struct {
	NameFilter  interface{} `json:"nameFilter"`
	SitesFilter []string    `json:"sitesFilter"`
	PopsFilter  []string    `json:"popsFilter"`
	Off         int32       `json:"off"`
	Lim         int32       `json:"lim"`
}

func (q *Queries) ListTeams(ctx context.Context, arg ListTeamsParams) ([]Team, error) {
	rows, err := q.db.Query(ctx, listTeams,
		arg.NameFilter,
		arg.SitesFilter,
		arg.PopsFilter,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.DefaultEscalationPolicyID,
			&i.DefaultChannel,
			&i.AssignedSites,
			&i.AssignedPops,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamsCount = `-- name: ListTeamsCount :one
SELECT COUNT(*) FROM teams
WHERE
    (COALESCE(NULLIF($1, ''), '') = '' OR name ILIKE '%' || $1 || '%')
    AND (COALESCE(cardinality($2::text[]), 0) = 0 OR assigned_sites && $2::text[])
    AND (COALESCE(cardinality($3::text[]), 0) = 0 OR assigned_pops && $3::text[])
`

type ListTeamsCountParams struct {
	NameFilter  interface{} `json:"nameFilter"`
	SitesFilter []string    `json:"sitesFilter"`
	PopsFilter  []string    `json:"popsFilter"`
}

func (q *Queries) ListTeamsCount(ctx context.Context, arg ListTeamsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, listTeamsCount, arg.NameFilter, arg.SitesFilter, arg.PopsFilter)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const removeTeamMember = `-- name: RemoveTeamMember :exec
DELETE FROM team_members
WHERE team_id = $1 AND user_id = $2
`

type RemoveTeamMemberParams struct {
	TeamID uuid.UUID `json:"teamId"`
	UserID uuid.UUID `json:"userId"`
}

func (q *Queries) RemoveTeamMember(ctx context.Context, arg RemoveTeamMemberParams) error {
	_, err := q.db.Exec(ctx, removeTeamMember, arg.TeamID, arg.UserID)
	return err
}

const updateRoutingRule = `-- name: UpdateRoutingRule :one
UPDATE routing_rules
SET
    name = COALESCE(NULLIF($1, ''), name),
    description = COALESCE($2, description),
    priority = COALESCE(NULLIF($3::int, 0), priority),
    enabled = $4,
    conditions = COALESCE($5, conditions),
    actions = COALESCE($6, actions),
    terminal = $7,
    time_condition = $8,
    tags = COALESCE($9, tags),
    updated_by = $10,
    updated_at = NOW()
WHERE id = $11
RETURNING id, name, description, priority, enabled, conditions, actions, terminal, time_condition, tags, created_by, created_at, updated_by, updated_at
`

type UpdateRoutingRuleParams struct {
	Name          interface{}     `json:"name"`
	Description   pgtype.Text     `json:"description"`
	Priority      int32           `json:"priority"`
	Enabled       bool            `json:"enabled"`
	Conditions    json.RawMessage `json:"conditions"`
	Actions       json.RawMessage `json:"actions"`
	Terminal      bool            `json:"terminal"`
	TimeCondition []byte          `json:"timeCondition"`
	Tags          []string        `json:"tags"`
	UpdatedBy     pgtype.UUID     `json:"updatedBy"`
	ID            uuid.UUID       `json:"id"`
}

func (q *Queries) UpdateRoutingRule(ctx context.Context, arg UpdateRoutingRuleParams) (RoutingRule, error) {
	row := q.db.QueryRow(ctx, updateRoutingRule,
		arg.Name,
		arg.Description,
		arg.Priority,
		arg.Enabled,
		arg.Conditions,
		arg.Actions,
		arg.Terminal,
		arg.TimeCondition,
		arg.Tags,
		arg.UpdatedBy,
		arg.ID,
	)
	var i RoutingRule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Priority,
		&i.Enabled,
		&i.Conditions,
		&i.Actions,
		&i.Terminal,
		&i.TimeCondition,
		&i.Tags,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRoutingRulePriority = `-- name: UpdateRoutingRulePriority :exec
UPDATE routing_rules
SET priority = $1, updated_at = NOW()
WHERE id = $2
`

type UpdateRoutingRulePriorityParams struct {
	Priority int32     `json:"priority"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) UpdateRoutingRulePriority(ctx context.Context, arg UpdateRoutingRulePriorityParams) error {
	_, err := q.db.Exec(ctx, updateRoutingRulePriority, arg.Priority, arg.ID)
	return err
}

const updateTeam = `-- name: UpdateTeam :one
UPDATE teams
SET
    name = COALESCE(NULLIF($1, ''), name),
    description = COALESCE($2, description),
    default_escalation_policy_id = $3,
    default_channel = COALESCE($4, default_channel),
    assigned_sites = COALESCE($5, assigned_sites),
    assigned_pops = COALESCE($6, assigned_pops),
    metadata = COALESCE($7, metadata),
    updated_at = NOW()
WHERE id = $8
RETURNING id, name, description, default_escalation_policy_id, default_channel, assigned_sites, assigned_pops, metadata, created_at, updated_at
`

type UpdateTeamParams struct {
	Name                      interface{}     `json:"name"`
	Description               pgtype.Text     `json:"description"`
	DefaultEscalationPolicyID pgtype.UUID     `json:"defaultEscalationPolicyId"`
	DefaultChannel            []byte          `json:"defaultChannel"`
	AssignedSites             []string        `json:"assignedSites"`
	AssignedPops              []string        `json:"assignedPops"`
	Metadata                  json.RawMessage `json:"metadata"`
	ID                        uuid.UUID       `json:"id"`
}

func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) (Team, error) {
	row := q.db.QueryRow(ctx, updateTeam,
		arg.Name,
		arg.Description,
		arg.DefaultEscalationPolicyID,
		arg.DefaultChannel,
		arg.AssignedSites,
		arg.AssignedPops,
		arg.Metadata,
		arg.ID,
	)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.DefaultEscalationPolicyID,
		&i.DefaultChannel,
		&i.AssignedSites,
		&i.AssignedPops,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTeamMember = `-- name: UpdateTeamMember :exec
UPDATE team_members
SET role = $1, preferences = $2
WHERE team_id = $3 AND user_id = $4
`

type UpdateTeamMemberParams struct {
	Role        TeamRole  `json:"role"`
	Preferences []byte    `json:"preferences"`
	TeamID      uuid.UUID `json:"teamId"`
	UserID      uuid.UUID `json:"userId"`
}

func (q *Queries) UpdateTeamMember(ctx context.Context, arg UpdateTeamMemberParams) error {
	_, err := q.db.Exec(ctx, updateTeamMember,
		arg.Role,
		arg.Preferences,
		arg.TeamID,
		arg.UserID,
	)
	return err
}
